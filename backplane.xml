<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="./lib/xslt/rfc2629.xslt" ?>
<!DOCTYPE rfc SYSTEM "./lib/xslt/rfc2629.dtd" [
  <!ENTITY RFC2119 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
  <!ENTITY RFC2616 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2616.xml">
  <!ENTITY RFC2617 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2617.xml">
  <!ENTITY RFC4627 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4627.xml">
]>
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="3"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc private="Echo"?>
<rfc>
  <front><!-- [[[ -->
    <title abbrev="Backplane">Backplane v2 - draft 01</title>

    <author>
      <organization>Echo</organization>
    </author>

    <author fullname="Carl Howells" initials="C." surname="Howells">
      <organization>Janrain</organization>
      <address>
        <email>chowells@janrain.com</email>
        <uri>http://www.janrain.com/</uri>
      </address>
    </author>

    <author fullname="Johnny Bufu" initials="J." surname="Bufu">
      <organization>Janrain</organization>
      <address>
        <email>jbufu@janrain.com</email>
        <uri>http://www.janrain.com/</uri>
      </address>
    </author>

    <date day="12" month="April" year="2011" />

    <keyword>Internet-Draft</keyword>
    
    <abstract>
      <t>Backplane is a framework that facilitates message exchanges
          and event notifications between third-party JavaScript
          components within a web page.</t>
    </abstract>

  </front><!-- ]]] -->

  <middle><!-- [[[ -->
    <section anchor="introduction" title="Introduction"><!-- [[[ -->
      <t>Web pages have evolved from being loaded from a single resource
          to being able to reference third-party, external components
          that get loaded, run and rendered by the web browser within
          the same web page.</t>

      <t>These components can be active and continue to run after the
          web page completed loading and are generally decoupled
          &mdash; not under the control of a single entity.</t>

      <t>Interactions between the end user, the web page, and its
          features provided through such components can greatly benefit
          when all parties involved can exchange information with each
          other, and can do it in a standardized way.</t>

      <t>The Backplane framework facilitates such interactions by
          providing an open standard API that is secure in the context
          of the assumed trust relationships between the parties
          involved. Messages are delivered reliably, in order and in
          nearly real-time fashion. The framework may be used in
          different scenarios which build on top of the transport-level
          semantics described in this document.</t>
    </section><!-- ]]] -->


    <section anchor="definitions" title="Definitions">

      <t>
        <list style="hanging">

          <t hangText="Web Page">
            Document obtained from a web resource and loaded by the end
            user's web browser.
          </t>

          <t hangText="Widget">
            Third-party JavaScript component referenced from the Web
            Page that is loaded and run in the end user's browser.
          </t>

          <t hangText="Backplane Client">
            Entity that uses the Backplane framework to exchange
            information.
          </t>

          <t hangText="Backplane Message">
            A JSON object representing the unit of communication between
            Backplane Clients.
          </t>

          <t hangText="Backplane Header">
            A Backplane Message without the payload field.
          </t>

          <t hangText="Backplane JavaScript API">
            JavaScript API used by Widgets to initialize and subscribe
            to Backplane Messages.
          </t>

          <t hangText="Backplane JavaScript Library">
            Backplane JavaScript API implementation.
          </t>

          <t hangText="Backplane Server API">
            Server API through which Backplane Clients send and retrieve
            Backplane Messages.
          </t>

          <t hangText="Backplane Server">
            Backplane Server API implementation.
          </t>

          <t hangText="Backplane Frame">
            A Backplane Message and metadata assigned to it by the
            Backplane Server.
          </t>

          <t hangText="Backplane Frame Header">
            A Backplane Frame without the Backplane Message payload field.
          </t>

          <t hangText="Bus">
            Identifier for a logical grouping of Backplane Clients that
            need to interact with each other, typically belonging to one
            organization.
          </t>

          <t hangText="Channel">
            Identifier for a subset of Backplane Messages on a Bus that
            are addressed to the Backplane Clients interacting with the
            end user through a single session and Web Page.
          </t>

          <t hangText="Channel Name">
            The part of the Channel identifier that is unique within a
            Bus.
          </t>

        </list>
      </t>

      <section title="Requirements Language">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
          NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
          "OPTIONAL" in this document are to be interpreted as described
          in <xref target="RFC2119">RFC 2119</xref>.</t>
      </section>
      
    </section>

    <section anchor="overview" title="Overview"><!-- [[[ -->
      <t>
        An operational Backplane framework consists of the following
        components:
        <list style="symbols">
          <t>A Backplane Server</t>
          <t>A Backplane JavaScript Library</t>
          <t>Widgets that act as Backplane Clients</t>
          <t>Widgets' server-side counterparts that act as Backplane Clients.</t>
        </list>
      </t>

      <t>A Backplane Server is an independent orchestrator of the
        message interchange between Backplane Clients and may serve
        multiple independent Buses.</t>

      <t>A Backplane framework instance needs to be configured prior to use:
        all Backplane Clients and the Server have to share the same Bus. 
        Backplane Clients operating at the
        <xref target="access.level.privileged">Privileged Access Level</xref>
        need a password to authenticate themselves to the Server. It is
        outside the scope of this document how such configuration is
        performed.</t>

    </section> <!-- ]]] -->

    <section anchor="trust" title="Trust">
      <t>
        The Backplane framework is intended to be used and operate under
        the following trust relationships. Any number of security issues
        can arise if any of these assumptions do not hold.</t>
      <t>
        <list>
          <t>
            The end user trusts the Web Page owner (and indirectly all
            Widget owners) that the Web Page will not attack or exploit
            their web browser.
          </t>
          <t>
            The Web Page owner (and indirectly the end user) trusts all
            Widget owners that the Widgets will not abuse the Backplane
            framework by trying to impersonate other Widgets' behavior
            in order to obtain and access information that is not
            directed to them, such as end user account information
            addressed to other Widgets.
          </t>
          <t>
            The Web Page owner (and indirectly the end user), and
            Widget owners trust the Backplane Server API and Backplane
            JavaScript API implementations that they will comply with
            this specification.
          </t>
          <t>
            Backplane Clients trust the Bus owner and the authenticity
            of Backplane Messages received through a Bus, i.e all
            Backplane Clients that were granted permission to post on
            the Bus by its owner.
          </t>
        </list>
      </t>
    </section>

    <section anchor="access.levels" title="Access Levels">

      <t>
        Considering the significantly different security enforcement
        capabilities of applications running in a web browser versus the
        ones running on a web server, two access levels are defined for
        Backplane Clients: Regular and Privileged.
      </t>

      <section anchor="access.level.regular" title="Regular Access">
        <t>
          Regular access level is given to Backplane Clients running in
          the web browser (Widgets and the Backplane JavaScript Library).
        </t>
        <t>
          Regular access level is exercised without presenting any
          authorization credentials aside from the Channel identifier.
          Bus owners and Backplane Servers acting on their behalf MUST
          NOT give authorization credentials for Privileged access level
          to Backplane Clients running in the web browser.
        </t>
        <t>
          Backplane Clients having Regular access level can retrieve
          Backplane Frame Headers sent to Channels for which they know
          the Channel identifier.
        </t>
      </section>

      <section anchor="access.level.privileged" title="Privileged Access">
        <t>
          Privileged access level is given to Backplane Clients that
          are not running in a web browser, typically the Widgets'
          server-side components.
        </t>
        <t>
          Privileged access level is exercised by presenting
          authorization credentials obtained from the Bus owner for such
          operations. The authorization credentials MUST be sent using
          HTTP Basic Authentication with the corresponding Backplane
          Server API requests. Backplane Servers MUST validate the
          authorization credentials for all Backplane Server API
          operations that require Privileged access level, summarized
          below.
          See <xref target="backplane.server.api">Backplane Server API</xref>.
          The provisioning of Privileged access level credentials is
          outside of the scope of this specification.
        </t>
        <t>
          Backplane Clients having Privileged access level can perform
          the following operations on a Bus for which they have obtained
          authorization credentials from the Bus owner:
          <list style="symbols">
            <t>
              retrieve Backplane Messages (which include payloads) that
              were sent to a Channel for which they know the Channel
              identifier
            </t>
            <t>
              retrieve all Backplane Messages sent to the Bus
            </t>
            <t>
              post Backplane Messages to a Channel for which they know
              the Channel identifier
            </t>
          </list>
        </t>
      </section>

    </section>

    <section anchor="buses" title="Buses">
      <t>
        A Bus is an identifier for a logical grouping of Backplane
        Clients that need to interact with each other, typically
        belonging to one organization. The Bus identifier acts as a 
        namespace for the Backplane Messages exchanged by the group.
      </t>
      <t>
        Bus identifiers allow a Backplane Server to service multiple
        customers and can consist of short strings referencing the Bus
        owner's name (e.g. "customer.com", "organization.org").
      </t>
      <t>
        Backplane Clients must know the identifiers for the Buses
        through which they wish to exchange Backplane Messages.
      </t>
      <t>
        It is assumed that a relationship of trust exists between all
        clients granted permission to post messages to a specific
        bus. See <xref target="trust">Trust</xref>.
      </t>
      <figure>
        <preamble>
          Example of a Bus identifier:
        </preamble>
        <artwork type="code">http://backplane.example.com/v2/bus/customer.com</artwork>
      </figure>
    </section>

    <section anchor="channels" title="Channels">
      <t>
        A Channel is an identifier for a subset of Backplane Messages on
        a Bus that are addressed to the Backplane Clients interacting
        with the end user through a single session and Web Page.
      </t>
      <t>
        A Channel is similar to a session identifier for the user but is
        shared by all Backplane Clients. All Backplane Clients that know
        a given Channel identifier can receive Backplane Messages posted
        to that Channel.
      </t>

      <t>Channels are:
        <list style="symbols">
          <t>allocated within Buses</t>
          <t>referenced by unique, unguessable identifiers (URLs)</t>
          <t>created implicitly once a Backplane message gets
            posted to a channel that doesn't yet exist</t>
          <t>non-persistent and expire after being inactive (no
            messages posted) for specific amount of time (e.g. 30
            minutes)</t>
          <t>sensitive (i.e. content that cannot be trusted to keep the
            channel identifier secret MUST NOT be loaded)</t>
        </list>
      </t>

      <t>Channel names MUST only contain characters from the
        <xref target="RFC4648.section5">base64url</xref>
        character set.
      </t>
      
      <figure>
        <preamble>
          Example of a Channel identifier:
        </preamble>
        <artwork type="code">http://backplane.example.com/v2/bus/customer.com/channel/8ec92f459fa70b0da1a40e8fe70a0bc8</artwork>
      </figure>
    </section>

    <section anchor="backplane.messages" title="Backplane Messages">
      <t>A Backplane message is a JSON object with the following fields:
        <list style="hanging">
          <t hangText="source">
            the source of the message, MUST be a URL
            (e.g. "http://client.com/")
          </t>
          <t hangText="type">
            message type, string
          </t>
          <t hangText="payload">
            arbitrary object carrying data specific to the particular 
            message type
          </t>
        </list>
      </t>

      <t>
        A Backplane message MAY be wrapped in a
        <xref target="draft-panzer-magicsig-00">Magic Envelope</xref>.
        Backplane Clients MUST be able to process (unwrap) such messages
        (note that unwrapping a magic envelope is not the same as
        signature verification).
      </t>
    </section>


    <section anchor="backplane.frames" title="Backplane Frames">
      <t>
        A Backplane frame is a JSON object with the following fields:
        <list style="hanging">
          <t hangText="message">
            the Backplane Message
          </t>
          <t hangText="channel_name">
            the Channel Name the message was posted to (can be used to
            construct Channel identifier of the message)
          </t>
          <t hangText="id">
            an arbitrary string identifier assigned by the server to
            the message for the purpose of later referencing
          </t>
        </list>
      </t>
      <t>
        For the purpose of managing and referencing Backplane Messages,
        a Backplane Server wraps them with the meta information
        described above into Backplane Frames.
      </t>

    </section>

    <section anchor="backplane.server.api" title="Backplane Server API"><!-- [[[ -->

      <section anchor="backplane.server.conventions" title="Message Retrieval Conventions">
        <t>
          A Backplane Server maintains a "window" of most recent
          messages for each of the existing buses and channels. The
          exact amount of messages that fit into the window depends
          on the server implementation or policy.
        </t>

        <t>
          All Backplane Server API methods dealing with Backplane
          Message retrieval observe the principles outlined below. A
          retrieval request may contain an optional 'since' parameter,
          referring to a message previously seen by the caller.
        </t>

        <t>
          If the 'since' parameter is...
          <list>
            <t>...omitted, the whole window worth of Backplane Messages
              is returned.</t>
            <t>...present and refers to a Backplane Message...
              <list>
                <t>...currently residing in the window, the Backplane
                  Server returns all Backplane Messages that are more
                  recent than the referenced one.</t>
                <t>...which is no longer in the window, the whole window
                  worth of Backplane Messages is returned.</t>
              </list>
            </t>
          </list>
        </t>

        <t>In order to avoid omissions, a Backplane Client needs to
          invoke the method often enough (specific recommendations
          will be based on the server implementation or policy).</t>

      </section>

      <t>A Backplane Server provides the following API.</t>

      <section anchor="backplane.server.api.new_channel" title="Get a
        New Channel Name">
        <t>
          <list style="hanging">
            <t hangText="Endpoint">
              <spanx style="verb">/v2/new_channel</spanx></t>
            <t hangText="HTTP Method">GET</t>
            <t hangText="Security">HTTPS only,
              <xref target="access.level.regular">Regular Access Level</xref></t>
            <t hangText="Parameters">None</t>
            <t hangText="Returns">a new, securely-generated Channel Name</t>
          </list>
        </t>
        <t>
          This call exists to help the Backplane JavaScript Library
          provision new Channel Names. Since JavaScript provides no
          method to generate unguessable values, it needs server-side
          assistance.
        </t>
        <t>
          The result value of this call should be 32 characters
          indepedently chosen uniformly from the set
          <spanx style="emph">0123456789abcdef</spanx>. The content
          returned must not be guessable given knowledge of the
          algorithms in use or any details of the request being
          made.
        </t>
        <t>
          As an operational note, this API call should not be
          implemented in a way that makes it capable of blocking or
          exhausting any system resources.
        </t>
      </section>

      <section anchor="backplane.server.api.bus" title="Get All
        Messages In A Bus">
        <t><list style="hanging">
            <t hangText="Endpoint">
              <spanx style="verb">/v2/bus/&lt;BUS_NAME&gt;</spanx></t>
            <t hangText="HTTP Method">GET</t>
            <t hangText="Security">HTTPS with
              <xref target="access.level.privileged">Privileged Access Level</xref></t>
            <t hangText="Parameters">
              since (optional): Backplane Message identifier (see
              <xref target="backplane.server.conventions">Message Retrieval Conventions</xref>
              above)
            </t>
            <t hangText="Returns">a JSON object consisting of a list of
              Backplane Frames</t>
          </list>
        </t>
        <t>
          This method is used by Backplane Clients to receive all
          messages distributed on the specific Bus &lt;BUS_NAME&gt;.
        </t>
      </section>

      <section anchor="backplane.server.api.channel.get"
        title="Get Channel Messages">
        <t><list style="hanging">
            <t hangText="Endpoint">
              <spanx style="verb">/v2/bus/&lt;BUS_NAME&gt;/channel/&lt;CHANNEL_NAME&gt;</spanx></t>
            <t hangText="HTTP Method">GET</t>
            <t hangText="Security">
              <xref target="access.level.privileged">Privileged Access Level</xref>
              with HTTPS, or
              <xref target="access.level.regular">Regular Access Level</xref>
              with either HTTP or HTTPS.
            </t>
            <t hangText="Parameters">
              since (optional): Backplane Message identifier (see
              <xref target="backplane.server.conventions">Message Retrieval Conventions</xref>
              above)
            </t>
            <t hangText="Returns">a JSON object consisting of a list of
              Backplane Frames or Backplane Frame Headers, depending on
              the access level used by the requester.</t>
        </list>
        </t>
        <t>
          With <xref target="access.level.privileged">Privileged Access Level</xref>
          this method is used by server-side components to receive Backplane
          Frames that were posted to a specific Channel.
        </t>
        <t>
          With <xref target="access.level.regular">Regular Access Level</xref>
          this method is used by Widgets to receive Backplane Frame
          Headers for Backplane Messages that were posted to a specific
          Channel.
        </t>
      </section>

      <section anchor="backplane.server.api.channel.post"
        title="Post Messages To A Channel">
        <t><list style="hanging">
            <t hangText="Endpoint">
              <spanx style="verb">/v2/bus/&lt;BUS_NAME&gt;/channel/&lt;CHANNEL_NAME&gt;</spanx></t>
            <t hangText="HTTP Method">POST</t>
            <t hangText="HTTP Request Body">a JSON object consisting of
              a list of Backplane Messages to post to the channel</t>
            <t hangText="Security">HTTPS,
              <xref target="access.level.privileged">Privileged Access Level</xref></t>
          </list>
        </t>
        <t>
          This method injects one or more Backplane Messages to the
          Channel. If Channel &lt;CHANNEL_NAME&gt; doesn't exist, it
          is created.</t>
      </section>

    </section><!-- ]]] -->

    <section anchor="backplane.javascript.api" title="Backplane JavaScript API"><!-- [[[ -->

      <t>A Backplane JavaScript Library runs in an end user's browser
        and mediates communication between Backplane-enabled Widgets on
        the page and the Backplane Server.</t>

      <t>Only one instance of the Backplane JavaScript Library on a
        given page is possible. The library has to be the first to load
        on the page to make it possible for other scripts to use its
        subscription functionality.</t>

      <figure>
        <preamble>The Backplane JavaScript Library provides the following
          API (all methods are static): </preamble>
        <artwork type="code">
/**
 * Initializes the backplane library
 *
 * @param {Object} Params - hash with configuration parameters.
 *   Possible hash keys:
 *     serverBaseURL (required) - Base URL of Backplane Server
 *     busName (required) - Customer's backplane bus name
 */
Backplane.init(Params);

/**
 * Subscribes to messages from Backplane server
 *
 * @param {Function} Callback - Callback function which accepts backplane messages.
 * @returns Subscription ID which can be used later for unsubscribing.
 */
Backplane.subscribe(Callback);

/**
 * Removes specified subscription
 *
 * @param {Integer} Subscription ID
 */
Backplane.unsubscribe(SubscriptionID);

/**
 * Returns channel ID (like http://backplane.customer.com/v2/bus/customer.com/channel/8ec92f459fa70b0da1a40e8fe70a0bc8)
 *
 * @returns Backplane channel ID
 */
Backplane.getChannelID();

/**
 * Notifies backplane library about the fact that subscribers are going
 * to receive backplane messages within specified time interval.
 *
 * @param {Integer} TimeInterval - Time interval in seconds
 * @param {Array} MessageTypes (optional) - a list of expected message types
 */
Backplane.expectMessagesWithin(TimeInterval, MessageTypes);
        </artwork>
      </figure>

      <section anchor="client.side.library.init"
        title="Initialization">
        <t>Backplane is initialized using the
          <spanx style="verb">Backplane.init</spanx> method.</t>

        <t>During initialization the library generates a random
          Channel Name unless information about one for the specified
          <spanx style="emph">bus name</spanx> already exists in the
          <spanx style="verb">backplane-channel</spanx> cookie. Since
          client-side generation of the channel name is non-secure,
          the library performs a request to obtain a channel name
          from the Backplane Server.</t>

        <t>After initialization the library stores the current Channel
          Name in the <spanx style="verb">backplane-channel</spanx>
          cookie set against the complete domain name of currently
          opened page. The cookie is set for 5 years in advance and
          keeps information about association of Bus names to Channel
          Names (to support possibility to use the library with several
          different Bus names on the same domain). The information
          about the association is stored in a serialized form.</t>

        <figure>
          <preamble>Here is an example of cookie that stores association
            of Bus names <spanx style="verb">example.com</spanx> and
            <spanx style="verb">example.org</spanx> to the corresponding
            channel names <spanx style="verb">123</spanx> and
            <spanx style="verb">456</spanx>:</preamble>
          <artwork type="example">backplane-channel=example.com:123|example.org:456</artwork>
        </figure>

        <t>After the channel ID has been determined, the library
          performs a first reading of messages from a channel, discards
          all of them (remembering only the identifier of the very
          last one) and starts polling the Backplane Server for new
          messages since the latest Backplane Message. This way the
          library is guaranteed to push to subscribers only those
          Backplane Messages which arrived after the library had been
          fully initialized.</t>

      </section>

      <section anchor="client.side.library.subscription"
          title="Subscription Management">
        <t>The library provides a method for Widgets to set up
          notification callbacks: <spanx style="verb">Backplane.subscribe</spanx>.
          The method returns a subscription id which can be later used
          for unsubscribing using the <spanx style="verb">Backplane.unsubscribe</spanx>
          method.</t>

        <t>After the initialization the library starts polling the
          Backplane Server for new events. All incoming events are
          delivered to the Widgets that have registered callbacks with
          the library. </t>

      </section>
      <section anchor="client.side.library.hints"
          title="Hints">
        <t>For performance reasons the Backplane JavaScript Library
          polls the Backplane Server with a low frequency (e.g once a
          minute). Since Backplane events usually are initiated on the
          client side (e.g. the user clicking a button), Widgets on the
          page are in a position to hint the library that a Backplane
          message may be soon delivered. Upon the receipt of such hint
          (via <spanx style="verb">expectMessagesWithin</spanx> method),
          the library temporarily increases the polling frequency (e.g.
          to once a second) and then gradually decreases it to the
          default low value one.</t>

        <t>The <spanx style="verb">expectMessagesWithin</spanx> method
          can accept an optional list of expected message types.
          <list>
            <t>If the library accepts <spanx style="emph">any</spanx>
              message from the passed message types list, it gradually
              returns to the lower polling frequency mode;</t>
            <t>If messages with only one type are expected, the second
              argument may be specified as a string;</t>
            <t>Each call of the method adds passed message types to the
              list of expected message types. In other words, if
              a user calls the method with a message type "type1" and
              then performs one more call with a message type "type2",
              the library will run in the fast polling mode until it
              received messages of <spanx style="emph">all</spanx>
              the types or until the libray reached the maximum allotted
              waiting time interval.</t>
          </list>
        </t>
      </section>

      <section anchor="client.side.library.example"
          title="Usage Example">
        <figure><artwork type="code">
Backplane.init({
    serverBaseURL: "http://backplane.customer.com/v2",
    busName: "customer.com"
});

var escSubscription = Backplane.subscribe(function(backplaneMessage) {
    alert(backplaneMessage.payload);
});

// We can ask the library to perform more frequent polling
// if a widget, for example, expects a message from Backplane pretty soon
// using the expectMessagesWithin method which accepts
// time interval of possible message arrival in seconds
Backplane.expectMessagesWithin(10);

// The method can accept an option list with expected message types.
// The library stops fast polling when it receives a message of
// either type.
Backplane.expectMessagesWithin(10, ["type1", "type2"]);

// Subsequent calls extend the list of expected message types.
// The library stops fast polling only after it has received
// a message of type1 or type2 AND a message of type3 or type4.
Backplane.expectMessagesWithin(10, ["type3", "type4"]);

Backplane.unsubscribe(escSubscription);

// If a widget needs Backplane channel ID it can get it using the
// getChannelID method
Backplane.getChannelID();
        </artwork></figure>
      </section>
    </section><!-- ]]] -->
  </middle><!-- ]]] -->

  <back><!-- [[[ -->
    <references title="Normative References"><!-- [[[ -->

      &RFC2616;

      &RFC2617;

      &RFC4627;

      &RFC2119;

      <reference
        anchor="draft-panzer-magicsig-00"
        target="http://salmon-protocol.googlecode.com/svn/trunk/draft-panzer-magicsig-00.html#anchor3">
        <front>
          <title>Magic Signatures</title>
          <author initials="J." surname="Panzer" fullname="J. Panzer">
            <organization>Google Inc.</organization>
          </author>
          <author initials="B." surname="Laurie" fullname="B. Laurie">
            <organization>Google Inc.</organization>
          </author>
          <date year="2010" month="February" />
        </front>
      </reference>

      <reference
        anchor="RFC4648.section5"
        target="http://tools.ietf.org/html/rfc4648#section-5">
        <front>
          <title>The Base16, Base32, and Base64 Data Encodings</title>
          <author initials="S." surname="Josefsson"
            fullname="S. Josefsson">
            <organization>SJD</organization>
          </author>
          <date year="2006" month="October" />
        </front>
      </reference>
    </references><!-- ]]] -->
  </back><!-- ]]] -->
</rfc>
<!-- vim: set ts=2 sts=2 sw=2 tw=72 et fdm=marker fmr=[[[,]]]: -->
