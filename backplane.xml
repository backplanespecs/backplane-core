<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="./lib/xslt/rfc2629.xslt" ?>
<!DOCTYPE rfc SYSTEM "./lib/xslt/rfc2629.dtd" [
  <!ENTITY RFC2119 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
  <!ENTITY RFC2616 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2616.xml">
  <!ENTITY RFC4086 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4086.xml">
  <!ENTITY RFC4627 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4627.xml">
]>
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="3"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc private="Echo"?>
<rfc>
  <front><!-- [[[ -->
    <title abbrev="Backplane">Backplane</title>

    <author>
      <organization>Echo</organization>
    </author>

    <date day="5" month="April" year="2011" />

    <abstract>
      <t>Backplane is a framework that facilitates message exchanges
          and event notifications between third-party JavaScript
          components within a web page.</t>
    </abstract>

  </front><!-- ]]] -->

  <middle><!-- [[[ -->
    <section anchor="introduction" title="Introduction"><!-- [[[ -->
      <t>Web pages have evolved from being loaded from a single resource
          to being able to reference third-party, external components
          that get loaded, run and rendered by the web browser within
          the same web page.</t>

      <t>These components can be active and continue to run after the
          web page completed loading and are generally decoupled
          - not under the control of a single entity.</t>

      <t>Interactions between the end user, the web page, and its
          features provided through such components can greatly benefit
          when all parties involved can exchange information with each
          other, and can do it in a standardized way.</t>

      <t>The Backplane framework facilitates such interactions by
          providing an open standard API that is secure in the context
          of the assumed trust relationships between the parties
          involved. Messages are delivered reliably, in order and in
          nearly real-time fashion. The framework may be used in
          different scenarios which build on top of the transport-level
          semantics described in this document.</t>
    </section><!-- ]]] -->


    <section anchor="definitions" title="Definitions">

      <t>
        <list style="hanging">

          <t hangText="Web Page">
            Document obtained from a web resource and loaded by the
            end user's web browser.
          </t>

          <t hangText="Widget">
            Third-party JavaScript component referenced from the
            Web Page that is loaded and run in the end user's browser.
          </t>

          <t hangText="Backplane Client">
            Entity that uses the Backplane framework to exchange
            information.
          </t>

          <t hangText="Backplane Message">
            A JSON object representing the unit of communication
            between Backplane Clients.
          </t>

          <t hangText="Backplane JavaScript API">
            JavaScript API used by Widgets to initialize and
            subscribe to Backplane Messages.
          </t>

          <t hangText="Backplane JavaScript Library">
            Backplane JavaScript API implementation.
          </t>

          <t hangText="Backplane Server API">
            Server API through which Backplane Clients send and
            retrieve Backplane Messages.
          </t>

          <t hangText="Backplane Server">
            Backplane Server API implementation.
          </t>

          <t hangText="Backplane Frame">
            A Backplane Message and metadata assigned to it by the
            Backplane Server.
          </t>

          <t hangText="Bus">
            Identifier for a logical grouping of Backplane
            Clients that need to interact with each other,
            typically belonging to one organization.
          </t>

          <t hangText="Channel">
            Identifier for Backplane Messages within a Bus
            addressed to the Widgets loaded in a single session
            and Web Page by the end user.
          </t>

        </list>
      </t>

      <section title="Requirements Language">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
          NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
          "OPTIONAL" in this document are to be interpreted as described
          in <xref target="RFC2119">RFC 2119</xref>.</t>
      </section>

    </section>

    <section anchor="overview" title="Overview"><!-- [[[ -->
      <t>
        An operational Backplane framework consists of the following
        components:
        <list style="symbols">
          <t>A Backplane Server</t>
          <t>A Backplane JavaScript Library</t>
          <t>Widgets that act as Backplane Clients</t>
          <t>Widgets' server-side counterparts that act as Backplane Clients.</t>
        </list>
      </t>

      <t>A Backplane Server is an independent orchestrator of the
        message interchange between Backplane Clients and may serve
        multiple independent Buses.</t>
    </section> <!-- ]]] -->

    <section anchor="trust" title="Trust">
      <t>The Backplane framework is intended to be used and operate under
        the following trust relationships. Any number of security issues
        can arrise if any of these assumptions do not hold.</t>
      <t>
        <list>
          <t>
            The end user trusts the Web Page owner (and indirectly all
            Widget owners) that the Web Page will not attack or exploit
            their web browser.
          </t>
          <t>
            The Web Page owner (and indirectly the end user) trusts all
            Widget owners that the Widgets will not abuse the Backplane
            framework by trying to impersonate other Widgets' behavior
            in order to obtain and access information that is not
            directed to them, such as end user account information
            addressed to other Widgets.
          </t>
          <t>
            The Web Page owner (and indirectly the end user), and
            Widget owners trust the Backplane Server API and Backplane
            JavaScript API implementations that they will comply with
            this specification.
          </t>
          <t>
            Backplane Clients generally do not have direct trust
            relationships with other Backplane Clients. Therefore the
            content of Backplane Messages that are received is not
            trusted - they are considered hints about events that may
            have occurred. For sensitive and reliable information
            Backplane Clients must contact trusted server-side endpoints.
          </t>
        </list>
      </t>
    </section>

    <section anchor="buses" title="Buses">
      <t>A bus is essentially a namespace to allow multiple customers
        to be served off a single server. A bus is referenced by a
        short identifier (e.g. "customer.com", "organization.org").
        Bus identifiers are known to all relevant parties
        beforehand.</t>
      <t>It is assumed that a relationship of trust exists between all
        clients granted permission to post messages to a specific
        bus.</t>
    </section>

    <section anchor="overview.channels" title="Channels">
      <t>Any message entering the Backplane is routed to a
        <spanx style="emph">channel</spanx> and gets delivered to all
        consumers of that channel.</t>

      <t>Channels are:
        <list style="symbols">
          <t>allocated within buses</t>
          <t>referenced by unique, unguessable identifiers (URLs)</t>
          <t>non-persistent and expire after being inactive (no
            messages posted) for specific amount of time (e.g. 30
            minutes)</t>
          <t>sensitive (ie, content that cannot be trusted to keep the
            channel identifier secret MUST NOT be loaded)</t>
        </list>
      </t>

      <figure>
        <preamble>
          Here is an example of a Backplane channel identifier:
        </preamble>
        <artwork type="code">http://backplane.customer.com/v1/bus/customer.com/channel/8ec92f459fa70b0da1a40e8fe70a0bc8</artwork>
      </figure>
    </section>

    <section anchor="backplane.messages" title="Backplane Messages"><!-- [[[ -->
      <t>A Backplane message is a JSON object with the following
        predefined fields:
        <list style="hanging">
          <t hangText="source">the source of the message, MUST be a URL
            ("http://client.com")</t>
          <t hangText="type">message type, string</t>
          <t hangText="payload">arbitrary object carrying data specific to the
            particular message type</t>
        </list>
      </t>

      <t>A Backplane message MAY be wrapped in a
        <xref target="draft-panzer-magicsig-00">Magic Envelope</xref>.
        Consumers MUST be able to process (unwrap) such messages (note
        that unwrapping a magic envelope is not the same thing as signature
        verification).</t>
    </section><!-- ]]] -->

    <section anchor="backplane.server" title="Backplane Server"><!-- [[[ -->
      <section anchor="backplane.server.channels" title="Channels">
        <t>Channels are created implicitly once a Backplane message gets
          posted to a channel that doesn't yet exist.</t>

        <t>Channel name MUST only contain characters from the
          <xref target="RFC4648.section5">base64url</xref>
          character set.</t>
      </section>

      <section anchor="backplane.server.conventions" title="Message Retrieval Conventions">
        <t>The server maintains a "window" of most recent messages for
          each of the existing buses and channels. The exact amount of
          messages that fit into the window depends on the server
          implementation or policy.</t>

        <t>All API methods dealing with message retrieval observe the
          principles outlined below. A retrieval request may contain an
          optional 'since' parameter, referring to a message previously
          seen by the caller.</t>

        <t>If the 'since' parameter is...
          <list>
            <t>...omitted, the whole window worth of messages is returned.</t>
            <t>...present and refers to a message...
              <list>
                <t>...currently residing in the window, the server
                  returns all messages that are more recent than the
                  referenced one.</t>
                <t>...which is no longer in the window, the whole window
                  worth of messages is returned.</t>
              </list>
            </t>
          </list>
        </t>

        <t>In order to avoid omissions, a client needs to invoke the
          method often enough (specific recommendations will be based on
          the server implementation or policy).</t>
      </section>

      <section anchor="backplane.server.frames" title="Message Frames">
        <t>Whenever a Backplane server needs to communicate
          metainformation along with a message, the Backplane message is
          wrapped into a "frame". The Backplane frame is a JSON object
          with the following fields:
          <list style="hanging">
            <t hangText="message">the Backplane message</t>
            <t hangText="channel_name">Name of the channel in a bus the message was
              posted to (can be used to construct Channel ID of the message)</t>
            <t hangText="id (string)">an arbitrary identifier assigned by the server to
              this message for the purpose of later referencing</t>
          </list>
        </t>
      </section>

      <section anchor="backplane.server.api" title="API">
        <t>A Backplane server provides the following API.</t>

        <section anchor="backplane.server.api.new_channel" title="Get A
          New Channel Name">
          <t><list style="hanging">
              <t hangText="Endpoint">
                <spanx style="verb">/v1/new_channel</spanx></t>
              <t hangText="HTTP Method">GET</t>
              <t hangText="Security">HTTPS only</t>
              <t hangText="Parameters">None</t>
              <t hangText="Returns">a new, securely-generated channel name</t>
            </list>
          </t>
          <t>This call exists to help the javascript library provision
          new channel names. Since javascript provides no method to
          generate unguessable values, it needs server-side
          assistance.</t>
          <t>The result value of this call MUST be 32 characters
          indepedently chosen with uniform distribution from the set
          <spanx style="emph">0123456789abcdef</spanx>. The content
          returned MUST NOT be guessable given knowledge of the
          algorithms in use or any details of the request being
          made.</t>
          <t>As operational notes, this API call SHOULD NOT be
          implemented in a way that makes it capable of blocking. Use
          of one of the mechanisms in section 7
          of <xref target="RFC4086">RFC 4086</xref> is
          RECOMMENDED.</t>
        </section>

        <section anchor="backplane.server.api.bus" title="Get All
          Messages In A Bus">
          <t><list style="hanging">
              <t hangText="Endpoint"><spanx style="verb">/v1/bus/&lt;BUS_NAME&gt;</spanx></t>
              <t hangText="HTTP Method">GET</t>
              <t hangText="Security">
                HTTPS with basic HTTP authentication</t>
              <t hangText="Parameters">
                since (optional): message identifier (see
                <xref target="backplane.server.conventions">Message Retrieval Conventions</xref>
                above)
              </t>
              <t hangText="Returns">a list of Backplane frames</t>
            </list>
          </t>
          <t>This method is used by Backplane clients to receive all
            messages distributed on the specific bus &lt;BUS_NAME&gt;.</t>
        </section>

        <section anchor="backplane.server.api.channel.get"
          title="Get Channel Messages">
          <t><list style="hanging">
              <t hangText="Endpoint">
                <spanx style="verb">/v1/bus/&lt;BUS_NAME&gt;/channel/&lt;CHANNEL_NAME&gt;</spanx></t>
              <t hangText="HTTP Method">GET</t>
              <t hangText="Security">none</t>
              <t hangText="Parameters">
                since (optional): message identifier (see
                <xref target="backplane.server.conventions">Message Retrieval Conventions</xref>
                above)
              </t>
              <t hangText="Returns">a list of Backplane frames</t>
            </list>
          </t>
          <t>This method is used by Backplane-enabled widgets to receive
            messages broadcast to a specific channel.</t>
        </section>

        <section anchor="backplane.server.api.channel.post"
          title="Post Messages To A Channel">
          <t><list style="hanging">
              <t hangText="Endpoint">
                <spanx style="verb">/v1/bus/&lt;BUS_NAME&gt;/channel/&lt;CHANNEL_NAME&gt;</spanx></t>
              <t hangText="HTTP Method">POST</t>
              <t hangText="HTTP Request Body">a list (JSON array) of
                Backplane messages to post to the channel</t>
              <t hangText="Security">
                HTTPS with basic HTTP authentication</t>
            </list>
          </t>
          <t>This method injects a message (or multiple messages) to the
            channel. If channel &lt;CHANNEL_NAME&gt; doesn't exist, it
            is created.</t>
        </section>

      </section>
    </section><!-- ]]] -->

    <section anchor="client.side.library" title="Client-side Backplane library API"><!-- [[[ -->

      <t>A Backplane Javascript library runs in an end user's browser
        and mediates communication between Backplane-enabled widgets on
        the page and the Backplane server.</t>

      <t>Only one instance of the Backplane library on a given page is
        possible. The library has to be the first to load on the page to
        make it possible for other scripts to use its subscription
        functionality.</t>

      <figure>
        <preamble>The library provides the following API (all methods are
          static):</preamble>
        <artwork type="code">
/**
 * Initializes the backplane library
 *
 * @param {Object} Params - hash with configuration parameters.
 *   Possible hash keys:
 *     serverBaseURL (required) - Base URL of Backplane Server
 *     busName (required) - Customer's backplane bus name
 */
Backplane.init(Params);

/**
 * Subscribes to messages from Backplane server
 *
 * @param {Function} Callback - Callback function which accepts backplane messages.
 * @returns Subscription ID which can be used later for unsubscribing.
 */
Backplane.subscribe(Callback);

/**
 * Removes specified subscription
 *
 * @param {Integer} Subscription ID
 */
Backplane.unsubscribe(SubscriptionID);

/**
 * Returns channel ID (like http://backplane.customer.com/v1/bus/customer.com/channel/8ec92f459fa70b0da1a40e8fe70a0bc8)
 *
 * @returns Backplane channel ID
 */
Backplane.getChannelID();

/**
 * Notifies backplane library about the fact that subscribers are going
 * to receive backplane messages within specified time interval.
 *
 * @param {Integer} TimeInterval - Time interval in seconds
 * @param {Array} MessageTypes (optional) - a list of expected message types
 */
Backplane.expectMessagesWithin(TimeInterval, MessageTypes);
        </artwork>
      </figure>

      <section anchor="client.side.library.init"
        title="Initialization">
        <t>Backplane is initialized using the
          <spanx style="verb">Backplane.init</spanx> method.</t>

        <t>During initialization the library generates a random
          <spanx style="emph">channel name</spanx> unless information about
          one for the specified <spanx style="emph">bus name</spanx>
          already exists in the <spanx style="verb">backplane-channel</spanx>
          cookie. Since client-side generation of the channel name is
          non-secure, the library performs a request to obtain a channel
          name from the backplane server.</t>

        <t>After the initialization the library stores the current
          channel name in the <spanx style="verb">backplane-channel</spanx>
          cookie set against complete domain name of currently opened
          page. The cookie is set for 5 years in advance and keeps
          information about association of bus names to channel names
          (to support possibility to use the library with several
          different bus names on the same domain). The information
          about the association is stored in a serialized form.</t>

        <figure>
          <preamble>Here is an example of cookie that stores
            association of bus names <spanx style="verb">example.com</spanx>
            and <spanx style="verb">example.org</spanx> to the corresponding
            channel names <spanx style="verb">123</spanx> and
            <spanx style="verb">456</spanx>:</preamble>
          <artwork type="example">backplane-channel=example.com:123|example.org:456</artwork>
        </figure>

        <t>After the channel ID has been determined, the library
          performs a first reading of messages from a channel, discards
          all of them (remembering only the identifier of the very
          last one) and starts polling the server for new messages
          since the latest message. This way the library is
          guaranteed to push to subscribers only those messages which
          arrived after the library had been fully initialized.</t>

      </section>

      <section anchor="client.side.library.subscription"
          title="Subscription Management">
        <t>The library provides a method for widgets to set up
          notification callbacks: <spanx style="verb">Backplane.subscribe</spanx>.
          The method returns subscription id which can be later used for
          unsubscribing using the <spanx style="verb">Backplane.unsubscribe</spanx>
          method.</t>

        <t>After the initialization the library starts polling the
          server for new events. All incoming events are delivered to
          the widgets that have registered callbacks with the
          library.</t>

      </section>
      <section anchor="client.side.library.hints"
          title="Hints">
        <t>For performance reasons the Backplane library polls the
          server quite infrequently (once a minute or so). Since
          Backplane events usually take their origin on the client
          side (e.g. the user clicking a button), widgets on the page
          are in a position to hint the library that a Backplane
          message may be soon delivered. Upon the receipt of such
          hint (via <spanx style="verb">expectMessagesWithin</spanx>
          method), the library temporarily changes the polling
          frequency (to once a second or so) and gradually increases
          it back to the default polling interval.</t>

        <t>The <spanx style="verb">expectMessagesWithin</spanx> method can
          accept an optional list of expected message types.
          <list>
            <t>If the library accepts <spanx style="emph">any</spanx> message
              from the passed message types list, it gradually returns to the slower
              polling frequency mode;</t>
            <t>If messages with only one type are expected, the second
              argument may be specified as a string;</t>
            <t>Each call of the method adds passed message types to the
              list of expected message types. In other words, if
              a user calls the method with a message type "type1" and then
              performs one more call with a message type "type2", the
              library will run in the fast polling mode until it
              received messages of <spanx style="emph">all</spanx>
              the types or until the libray reached the maximum allotted
              waiting time interval.</t>
          </list>
        </t>
      </section>

      <section anchor="client.side.library.example"
          title="Usage Example">
        <figure><artwork type="code">
Backplane.init({
    serverBaseURL: "http://backplane.customer.com/v1",
    busName: "customer.com"
});

var escSubscription = Backplane.subscribe(function(backplaneMessage) {
    alert(backplaneMessage.payload);
});

// We can ask the library to perform more frequent polling
// if a widget, for example, expects a message from Backplane pretty soon
// using the expectMessagesWithin method which accepts
// time interval of possible message arrival in seconds
Backplane.expectMessagesWithin(10);

// The method can accept an option list with expected message types.
// The library stops fast polling when it receives a message of
// either type.
Backplane.expectMessagesWithin(10, ["type1", "type2"]);

// Subsequent calls extend the list of expected message types.
// The library stops fast polling only after it has received
// a message of type1 or type2 AND a message of type3 or type4.
Backplane.expectMessagesWithin(10, ["type3", "type4"]);

Backplane.unsubscribe(escSubscription);

// If a widget needs Backplane channel ID it can get it using the
// getChannelID method
Backplane.getChannelID();
        </artwork></figure>
      </section>
    </section><!-- ]]] -->
  </middle><!-- ]]] -->

  <back><!-- [[[ -->
    <references title="Normative References"><!-- [[[ -->

      &RFC2616;

      &RFC4627;

      &RFC4086;

      &RFC2119;

      <reference
        anchor="draft-panzer-magicsig-00"
        target="http://salmon-protocol.googlecode.com/svn/trunk/draft-panzer-magicsig-00.html#anchor3">
        <front>
          <title>Magic Signatures</title>
          <author initials="J." surname="Panzer" fullname="J. Panzer">
            <organization>Google Inc.</organization>
          </author>
          <author initials="B." surname="Laurie" fullname="B. Laurie">
            <organization>Google Inc.</organization>
          </author>
          <date year="2010" month="February" />
        </front>
      </reference>

      <reference
        anchor="RFC4648.section5"
        target="http://tools.ietf.org/html/rfc4648#section-5">
        <front>
          <title>The Base16, Base32, and Base64 Data Encodings</title>
          <author initials="S." surname="Josefsson"
            fullname="S. Josefsson">
            <organization>SJD</organization>
          </author>
          <date year="2006" month="October" />
        </front>
      </reference>
    </references><!-- ]]] -->
  </back><!-- ]]] -->
</rfc>
<!-- vim: set ts=2 sts=2 sw=2 tw=72 et fdm=marker fmr=[[[,]]]: -->
