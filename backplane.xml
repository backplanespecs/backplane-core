<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="./lib/xslt/rfc2629.xslt" ?>
<!DOCTYPE rfc SYSTEM "./lib/xslt/rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="3"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc private="Echo"?>
<rfc>
  <front><!-- [[[ -->
    <title abbrev="Backplane">Backplane</title>

    <author fullname="Vlad Skvortsov" initials="V." surname="Skvortsov">
      <organization>Echo</organization>
      <address>
        <email>vss@aboutecho.com</email>
        <uri>http://aboutecho.com</uri>
      </address>
    </author>

    <author fullname="Chris Saad" initials="C." surname="Saad">
      <organization>Echo</organization>
      <address>
        <email>chris@aboutecho.com</email>
        <uri>http://aboutecho.com</uri>
      </address>
    </author>

    <author fullname="Yuri Lukyanov" initials="Y." surname="Lukyanov">
      <organization>Echo</organization>
      <address>
        <email>snaky@aboutecho.com</email>
        <uri>http://aboutecho.com</uri>
      </address>
    </author>

    <author fullname="Alexander Zhuravlev" initials="A."
      surname="Zhuravlev">
      <organization>Echo</organization>
      <address>
        <email>zaa@aboutecho.com</email>
        <uri>http://aboutecho.com</uri>
      </address>
    </author>

    <author fullname="Carl Howells" initials="C." surname="Howells">
      <organization>Janrain</organization>
      <address>
        <email>chowells@janrain.com</email>
        <uri>http://www.janrain.com/</uri>
      </address>
    </author>

    <date day="5" month="April" year="2011" />

    <abstract>
      <t>Backplane is a framework to facilitate interaction between
        multiple independent client- and server-side parties in the
        context of a browser session.</t>
    </abstract>

  </front><!-- ]]] -->

  <middle><!-- [[[ -->
    <section anchor="introduction" title="Introduction"><!-- [[[ -->
      <t>In essence Backplane is a message distribution system where
        messages are delivered reliably, in order and in nearly
        real-time fashion. The framework may be used in different
        scenarios which build on top of the transport-level semantics
        described in this document.</t>

      <section title="Requirements Language">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
          NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
          "OPTIONAL" in this document are to be interpreted as described
          in <xref target="RFC2119">RFC 2119</xref>.</t>
      </section>
    </section><!-- ]]] -->

    <section anchor="overview" title="Overview"><!-- [[[ -->
      <t>A Backplane setting consists of the following components:
        <list style="symbols">
          <t>A Backplane server</t>
          <t>A Client-side Backplane library (a Javascript library
            executed by an end user's browser)</t>
          <t>Backplane-enabled widgets</t>
          <t>Backplane clients</t>
        </list>
      </t>

      <t>A Backplane server is an independent orchestrator of the
        message interchange between the parties and may serve multiple
        independent <spanx style="emph">buses</spanx>.</t>

      <section anchor="overview.buses" title="Buses">
        <t>A bus is essentially a namespace to allow multiple customers
          to be served off a single server. A bus is referenced by a
          short identifier (e.g. "customer.com", "organization.org").
          Bus identifiers are known to all relevant parties
          beforehand.</t>
        <t>It is assumed that a relationship of trust exists between all
          clients granted permission to post messages to a specific
          bus.</t>
      </section>

      <section anchor="overview.channels" title="Channels">
        <t>Any message entering the Backplane is routed to a
          <spanx style="emph">channel</spanx> and gets delivered to all
          consumers of that channel.</t>

        <t>Channels are:
          <list style="symbols">
            <t>allocated within buses</t>
            <t>referenced by unique, unguessable identifiers (URLs)</t>
            <t>non-persistent and expire after being inactive (no
              messages posted) for specific amount of time (e.g. 30
              minutes)</t>
            <t>sensitive (ie, content that cannot be trusted to keep the
              channel identifier secret MUST NOT be loaded)</t>
          </list>
        </t>

        <figure>
          <preamble>
            Here is an example of a Backplane channel identifier:
          </preamble>
          <artwork type="code">http://backplane.customer.com/v1/bus/customer.com/channel/8ec92f459fa70b0da1a40e8fe70a0bc8</artwork>
        </figure>
      </section>
    </section> <!-- ]]] -->

    <section anchor="backplane.messages" title="Backplane Messages"><!-- [[[ -->
      <t>A Backplane message is a JSON object with the following
        predefined fields:
        <list style="hanging">
          <t hangText="source">the source of the message, MUST be a URL
            ("http://client.com")</t>
          <t hangText="type">message type, string</t>
          <t hangText="payload">arbitrary object carrying data specific to the
            particular message type</t>
        </list>
      </t>

      <t>A Backplane message MAY be wrapped in a
        <xref target="draft-panzer-magicsig-00">Magic Envelope</xref>.
        Consumers MUST be able to process (unwrap) such messages (note
        that unwrapping a magic envelope is not the same thing as signature
        verification).</t>
    </section><!-- ]]] -->

    <section anchor="backplane.server" title="Backplane Server"><!-- [[[ -->
      <section anchor="backplane.server.channels" title="Channels">
        <t>Channels are created implicitly once a Backplane message gets
          posted to a channel that doesn't yet exist.</t>

        <t>Channel name MUST only contain characters from the
          <xref target="RFC4648.section5">base64url</xref>
          character set.</t>
      </section>

      <section anchor="backplane.server.conventions" title="Message Retrieval Conventions">
        <t>The server maintains a "window" of most recent messages for
          each of the existing buses and channels. The exact amount of
          messages that fit into the window depends on the server
          implementation or policy.</t>

        <t>All API methods dealing with message retrieval observe the
          principles outlined below. A retrieval request may contain an
          optional 'since' parameter, referring to a message previously
          seen by the caller.</t>

        <t>If the 'since' parameter is...
          <list>
            <t>...omitted, the whole window worth of messages is returned.</t>
            <t>...present and refers to a message...
              <list>
                <t>...currently residing in the window, the server
                  returns all messages that are more recent than the
                  referenced one.</t>
                <t>...which is no longer in the window, the whole window
                  worth of messages is returned.</t>
              </list>
            </t>
          </list>
        </t>

        <t>In order to avoid omissions, a client needs to invoke the
          method often enough (specific recommendations will be based on
          the server implementation or policy).</t>
      </section>

      <section anchor="backplane.server.frames" title="Message Frames">
        <t>Whenever a Backplane server needs to communicate
          metainformation along with a message, the Backplane message is
          wrapped into a "frame". The Backplane frame is a JSON object
          with the following fields:
          <list style="hanging">
            <t hangText="message">the Backplane message</t>
            <t hangText="channel_name">Name of the channel in a bus the message was
              posted to (can be used to construct Channel ID of the message)</t>
            <t hangText="id (string)">an arbitrary identifier assigned by the server to
              this message for the purpose of later referencing</t>
          </list>
        </t>
      </section>

      <section anchor="backplane.server.api" title="API">
        <t>A Backplane server provides the following API.</t>

        <section anchor="backplane.server.api.channel_name" title="Get a
          New Channel Name">
          <t><list style="hanging">
              <t hangText="Endpoint">
                <spanx style="verb">/v1/channel_name</spanx></t>
              <t hangText="HTTP Method">GET</t>
              <t hangText="Security">HTTPS only</t>
              <t hangText="Parameters">None</t>
              <t hangText="Returns">a new, securely-generated channel name</t>
            </list>
          </t>
          <t>This call exists to help the javascript library provision
          new channel names. Since javascript provides no method to
          generate unguessable values, it needs server-side
          assistance.</t>
          <t>The result value of this call should be 32 characters
          indepedently chosen uniformly from the set
          <spanx style="emph">0123456789abcdef</spanx>. The content
          returned must not be guessable given knowledge of the
          algorithms in use or any details of the request being
          made.</t>
          <t>As an operational note, this API call should not be
          implemented in a way that makes it capable of blocking or
          exhausting any system resources.</t>
        </section>

        <section anchor="backplane.server.api.bus" title="Get All
          Messages In A Bus">
          <t><list style="hanging">
              <t hangText="Endpoint"><spanx style="verb">/v1/bus/&lt;BUS_NAME&gt;</spanx></t>
              <t hangText="HTTP Method">GET</t>
              <t hangText="Security">
                HTTPS with basic HTTP authentication</t>
              <t hangText="Parameters">
                since (optional): message identifier (see
                <xref target="backplane.server.conventions">Message Retrieval Conventions</xref>
                above)
              </t>
              <t hangText="Returns">a list of Backplane frames</t>
            </list>
          </t>
          <t>This method is used by Backplane clients to receive all
            messages distributed on the specific bus &lt;BUS_NAME&gt;.</t>
        </section>

        <section anchor="backplane.server.api.channel.get"
          title="Get Channel Messages">
          <t><list style="hanging">
              <t hangText="Endpoint">
                <spanx style="verb">/v1/bus/&lt;BUS_NAME&gt;/channel/&lt;CHANNEL_NAME&gt;</spanx></t>
              <t hangText="HTTP Method">GET</t>
              <t hangText="Security">none</t>
              <t hangText="Parameters">
                since (optional): message identifier (see
                <xref target="backplane.server.conventions">Message Retrieval Conventions</xref>
                above)
              </t>
              <t hangText="Returns">a list of Backplane frames</t>
            </list>
          </t>
          <t>This method is used by Backplane-enabled widgets to receive
            messages broadcast to a specific channel.</t>
        </section>

        <section anchor="backplane.server.api.channel.post"
          title="Post Messages To A Channel">
          <t><list style="hanging">
              <t hangText="Endpoint">
                <spanx style="verb">/v1/bus/&lt;BUS_NAME&gt;/channel/&lt;CHANNEL_NAME&gt;</spanx></t>
              <t hangText="HTTP Method">POST</t>
              <t hangText="HTTP Request Body">a list (JSON array) of
                Backplane messages to post to the channel</t>
              <t hangText="Security">
                HTTPS with basic HTTP authentication</t>
            </list>
          </t>
          <t>This method injects a message (or multiple messages) to the
            channel. If channel &lt;CHANNEL_NAME&gt; doesn't exist, it
            is created.</t>
        </section>

      </section>
    </section><!-- ]]] -->

    <section anchor="client.side.library" title="Client-side Backplane library API"><!-- [[[ -->

      <t>A Backplane Javascript library runs in an end user's browser
        and mediates communication between Backplane-enabled widgets on
        the page and the Backplane server.</t>

      <t>Only one instance of the Backplane library on a given page is
        possible. The library has to be the first to load on the page to
        make it possible for other scripts to use its subscription
        functionality.</t>

      <figure>
        <preamble>The library provides the following API (all methods are
          static):</preamble>
        <artwork type="code">
/**
 * Initializes the backplane library
 *
 * @param {Object} Params - hash with configuration parameters.
 *   Possible hash keys:
 *     serverBaseURL (required) - Base URL of Backplane Server
 *     busName (required) - Customer's backplane bus name
 */
Backplane.init(Params);

/**
 * Subscribes to messages from Backplane server
 *
 * @param {Function} Callback - Callback function which accepts backplane messages.
 * @returns Subscription ID which can be used later for unsubscribing.
 */
Backplane.subscribe(Callback);

/**
 * Removes specified subscription
 *
 * @param {Integer} Subscription ID
 */
Backplane.unsubscribe(SubscriptionID);

/**
 * Returns channel ID (like http://backplane.customer.com/v1/bus/customer.com/channel/8ec92f459fa70b0da1a40e8fe70a0bc8)
 *
 * @returns Backplane channel ID
 */
Backplane.getChannelID();

/**
 * Notifies backplane library about the fact that subscribers are going
 * to receive backplane messages within specified time interval.
 *
 * @param {Integer} TimeInterval - Time interval in seconds
 * @param {Array} MessageTypes (optional) - a list of expected message types
 */
Backplane.expectMessagesWithin(TimeInterval, MessageTypes);
        </artwork>
      </figure>

      <section anchor="client.side.library.init"
        title="Initialization">
        <t>Backplane is initialized using the
          <spanx style="verb">Backplane.init</spanx> method.</t>

        <t>During initialization the library generates a random
          <spanx style="emph">channel name</spanx> unless information about
          one for the specified <spanx style="emph">bus name</spanx>
          already exists in the <spanx style="verb">backplane-channel</spanx>
          cookie. Since client-side generation of the channel name is
          non-secure, the library performs a request to obtain a channel
          name from the backplane server.</t>

        <t>After the initialization the library stores the current
          channel name in the <spanx style="verb">backplane-channel</spanx>
          cookie set against complete domain name of currently opened
          page. The cookie is set for 5 years in advance and keeps
          information about association of bus names to channel names
          (to support possibility to use the library with several
          different bus names on the same domain). The information
          about the association is stored in a serialized form.</t>

        <figure>
          <preamble>Here is an example of cookie that stores
            association of bus names <spanx style="verb">example.com</spanx>
            and <spanx style="verb">example.org</spanx> to the corresponding
            channel names <spanx style="verb">123</spanx> and
            <spanx style="verb">456</spanx>:</preamble>
          <artwork type="example">backplane-channel=example.com:123|example.org:456</artwork>
        </figure>

        <t>After the channel ID has been determined, the library
          performs a first reading of messages from a channel, discards
          all of them (remembering only the identifier of the very
          last one) and starts polling the server for new messages
          since the latest message. This way the library is
          guaranteed to push to subscribers only those messages which
          arrived after the library had been fully initialized.</t>

      </section>

      <section anchor="client.side.library.subscription"
          title="Subscription Management">
        <t>The library provides a method for widgets to set up
          notification callbacks: <spanx style="verb">Backplane.subscribe</spanx>.
          The method returns subscription id which can be later used for
          unsubscribing using the <spanx style="verb">Backplane.unsubscribe</spanx>
          method.</t>

        <t>After the initialization the library starts polling the
          server for new events. All incoming events are delivered to
          the widgets that have registered callbacks with the
          library.</t>

      </section>
      <section anchor="client.side.library.hints"
          title="Hints">
        <t>For performance reasons the Backplane library polls the
          server quite infrequently (once a minute or so). Since
          Backplane events usually take their origin on the client
          side (e.g. the user clicking a button), widgets on the page
          are in a position to hint the library that a Backplane
          message may be soon delivered. Upon the receipt of such
          hint (via <spanx style="verb">expectMessagesWithin</spanx>
          method), the library temporarily changes the polling
          frequency (to once a second or so) and gradually increases
          it back to the default polling interval.</t>

        <t>The <spanx style="verb">expectMessagesWithin</spanx> method can
          accept an optional list of expected message types.
          <list>
            <t>If the library accepts <spanx style="emph">any</spanx> message
              from the passed message types list, it gradually returns to the slower
              polling frequency mode;</t>
            <t>If messages with only one type are expected, the second
              argument may be specified as a string;</t>
            <t>Each call of the method adds passed message types to the
              list of expected message types. In other words, if
              a user calls the method with a message type "type1" and then
              performs one more call with a message type "type2", the
              library will run in the fast polling mode until it
              received messages of <spanx style="emph">all</spanx>
              the types or until the libray reached the maximum allotted
              waiting time interval.</t>
          </list>
        </t>
      </section>

      <section anchor="client.side.library.example"
          title="Usage Example">
        <figure><artwork type="code">
Backplane.init({
    serverBaseURL: "http://backplane.customer.com/v1",
    busName: "customer.com"
});

var escSubscription = Backplane.subscribe(function(backplaneMessage) {
    alert(backplaneMessage.payload);
});

// We can ask the library to perform more frequent polling
// if a widget, for example, expects a message from Backplane pretty soon
// using the expectMessagesWithin method which accepts
// time interval of possible message arrival in seconds
Backplane.expectMessagesWithin(10);

// The method can accept an option list with expected message types.
// The library stops fast polling when it receives a message of
// either type.
Backplane.expectMessagesWithin(10, ["type1", "type2"]);

// Subsequent calls extend the list of expected message types.
// The library stops fast polling only after it has received
// a message of type1 or type2 AND a message of type3 or type4.
Backplane.expectMessagesWithin(10, ["type3", "type4"]);

Backplane.unsubscribe(escSubscription);

// If a widget needs Backplane channel ID it can get it using the
// getChannelID method
Backplane.getChannelID();
        </artwork></figure>
      </section>
    </section><!-- ]]] -->
  </middle><!-- ]]] -->

  <back><!-- [[[ -->
    <references title="Normative References"><!-- [[[ -->
      <reference anchor="RFC2119" target="http://tools.ietf.org/html/rfc2119">
        <front>
          <title abbrev="RFC Key Words">Key words for use in RFCs to Indicate Requirement Levels</title>
          <author initials="S." surname="Bradner" fullname="Scott Bradner">
            <organization>Harvard University</organization>
            <address>
              <email>sob@harvard.edu</email>
            </address>
          </author>
          <date year="1997" month="March" />
        </front>
      </reference>
    </references><!-- ]]] -->

    <references title="Informative References"><!-- [[[ -->
      <reference
        anchor="draft-panzer-magicsig-00"
        target="http://salmon-protocol.googlecode.com/svn/trunk/draft-panzer-magicsig-00.html#anchor3">
        <front>
          <title>Magic Signatures</title>
          <author initials="J." surname="Panzer" fullname="J. Panzer">
            <organization>Google Inc.</organization>
          </author>
          <author initials="B." surname="Laurie" fullname="B. Laurie">
            <organization>Google Inc.</organization>
          </author>
          <date year="2010" month="February" />
        </front>
      </reference>
      <reference
        anchor="RFC4648.section5"
        target="http://tools.ietf.org/html/rfc4648#section-5">
        <front>
          <title>The Base16, Base32, and Base64 Data Encodings</title>
          <author initials="S." surname="Josefsson"
            fullname="S. Josefsson">
            <organization>SJD</organization>
          </author>
          <date year="2006" month="October" />
        </front>
      </reference>
    </references><!-- ]]] -->
  </back><!-- ]]] -->
</rfc>
<!-- vim: set ts=2 sts=2 sw=2 tw=72 et fdm=marker fmr=[[[,]]]: -->
