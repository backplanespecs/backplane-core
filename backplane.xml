<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="./lib/xslt/rfc2629.xslt" ?>
<!DOCTYPE rfc SYSTEM "./lib/xslt/rfc2629.dtd" [
  <!ENTITY RFC2119 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
  <!ENTITY RFC2616 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2616.xml">
  <!ENTITY RFC2617 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2617.xml">
  <!ENTITY RFC4086 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4086.xml">
  <!ENTITY RFC4627 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4627.xml">
]>
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="3"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc private="Echo"?>
<rfc>
  <front>
    <title abbrev="Backplane">Backplane 2.0 - implementer's draft 08</title>

    <author fullname="Chris Saad" initials="C." surname="Saad"> 
      <organization>Echo</organization>
      <address>
        <email>chris@aboutecho.com</email>
        <uri>http://aboutecho.com</uri>
      </address>
    </author>

    <author fullname="Vlad Skvortsov" initials="V." surname="Skvortsov">
      <organization>Echo</organization>
      <address>
        <email>vss@aboutecho.com</email>                                                                                                      
        <uri>http://aboutecho.com</uri>
      </address>
    </author>

    <author fullname="Yuri Lukyanov" initials="Y." surname="Lukyanov">
      <organization>Echo</organization>
      <address>
        <email>snaky@aboutecho.com</email>
        <uri>http://aboutecho.com</uri>
      </address>
    </author>

    <author fullname="Alexander Zhuravlev" initials="A." surname="Zhuravlev">
      <organization>Echo</organization>
      <address>
        <email>zaa@aboutecho.com</email>
        <uri>http://aboutecho.com</uri>
      </address>
    </author>

    <author fullname="Ivan Glushkov" initials="I." surname="Glushkov">
      <organization>Echo</organization>
      <address>
        <email>gli@aboutecho.com</email>
        <uri>http://aboutecho.com</uri>
      </address>
    </author>

    <author fullname="Carl Howells" initials="C." surname="Howells">
      <organization>Janrain</organization>
      <address>
        <email>chowells@janrain.com</email>
        <uri>http://www.janrain.com/</uri>
      </address>
    </author>

    <author fullname="Johnny Bufu" initials="J." surname="Bufu">
      <organization>Janrain</organization>
      <address>
        <email>jbufu@janrain.com</email>
        <uri>http://www.janrain.com/</uri>
      </address>
    </author>

    <date day="12" month="January" year="2012" />

    <keyword>Internet-Draft</keyword>

    <abstract>
      <t>Backplane is a framework that facilitates message exchanges
          and event notifications between third-party JavaScript
          components within a web page.</t>
    </abstract>

  </front>

  <middle>
    <section anchor="introduction" title="Introduction">
      <t>Web pages have evolved from being loaded from a single resource
          to being able to reference third-party, external components
          that get loaded, run and rendered by the web browser within
          the same web page.</t>

      <t>These components can be active and continue to run after the
          web page completed loading and are generally decoupled
          &mdash; not under the control of a single entity.</t>

      <t>Interactions between the end user, the web page, and its
          features provided through such components can greatly benefit
          when all parties involved can exchange information with each
          other, and can do it in a standardized way.</t>

      <t>The Backplane framework facilitates such interactions by
          providing an open standard API that is secure in the context
          of the assumed trust relationships between the parties
          involved. Messages are delivered reliably and in order. The
          framework may be used in different scenarios which build on
          top of the transport-level semantics described in this
          document.</t>
    </section>


    <section anchor="definitions" title="Definitions">

      <t>
        <list style="hanging">

          <t hangText="Web Page">
            Document obtained from a web resource and loaded by the end
            user's web browser.
          </t>

          <t hangText="Widget">
            Third-party JavaScript component referenced from the Web
            Page that is loaded and run in the end user's browser.
          </t>

          <t hangText="Backplane Client">
            Entity that uses the Backplane framework to exchange
            information.
          </t>

          <t hangText="Backplane Message">
            A JSON object representing the unit of communication between
            Backplane Clients.
          </t>

          <t hangText="Message Identifier">
            Unique string assigned by Backplane Servers to each incoming
            Backplane Messages for the purpose of identifying and
            referencing them via the "since" retrieval mechanism.
          </t>

          <t hangText="Backplane Header">
            A Backplane Message without the payload field.
          </t>

          <t hangText="Backplane JavaScript API">
            JavaScript API used by Widgets to initialize and subscribe
            to Backplane Messages.
          </t>

          <t hangText="Backplane JavaScript Library">
            Backplane JavaScript API implementation.
          </t>

          <t hangText="Backplane Server API">
            Server API through which Backplane Clients send and retrieve
            Backplane Messages.
          </t>

          <t hangText="Backplane Server">
            Backplane Server API implementation.
          </t>

          <t hangText="Bus">
            Logical grouping of Backplane Clients that need to interact
            with each other, typically belonging to one organization.
          </t>

          <t hangText="Channel">
            Subset of Backplane Messages that belong to a Bus and are
            addressed to the Backplane Clients interacting with the end
            user through a single session and Web Page.
          </t>

          <t hangText="Message Sequence">
            A set of Backplane Messages that meet a certain filter criteria,
            in the same order as they have been received by a Backplane
            server.
          </t>

          <t hangText="Message Age">
            The length of time since the Message was received by the
            Backplane server.
          </t>

        </list>
      </t>

      <section title="Requirements Language">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
          NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
          "OPTIONAL" in this document are to be interpreted as described
          in <xref target="RFC2119">RFC 2119</xref>.</t>
      </section>

    </section>

    <section anchor="overview" title="Overview">
      <t>
        An operational Backplane framework consists of the following
        components:
        <list style="symbols">
          <t>A Backplane Server</t>
          <t>A Backplane JavaScript Library</t>
          <t>Widgets that act as Backplane Clients</t>
          <t>Widgets' server-side counterparts that act as Backplane Clients.</t>
        </list>
      </t>

      <t>A Backplane Server is an independent orchestrator of the
        message interchange between Backplane Clients and may serve
        multiple independent Buses.</t>

      <t>A Backplane framework instance needs to be configured prior to use:
        all Backplane Clients and the Server have to share the same Bus. 
        Backplane Clients operating at the
        <xref target="access.level.privileged">Privileged Access Level</xref>
        need a password to authenticate themselves to the Server.</t>

    </section>

    <section anchor="trust" title="Trust">
      <t>
        The Backplane framework is intended to be used and operate under
        the following trust relationships. Any number of security issues
        can arise if any of these assumptions do not hold.</t>
      <t>
        <list>
          <t>
            The end user trusts the Web Page owner (and indirectly all
            Widget owners) that the Web Page will not attack or exploit
            their web browser.
          </t>
          <t>
            The Web Page owner (and indirectly the end user) trusts all
            Widget owners that the Widgets will not abuse the Backplane
            framework by trying to impersonate other Widgets' behavior
            in order to obtain and access information that is not
            directed to them, such as end user account information
            addressed to other Widgets.
          </t>
          <t>
            The Web Page owner (and indirectly the end user), and
            Widget owners trust the Backplane Server API and Backplane
            JavaScript API implementations that they will comply with
            this specification.
          </t>
          <t>
            The Web Page owner (and indirectly the end user) trusts
            all content on the Web Page to not attack the widgets or
            the Backplane framework. This must explicitly include all
            JavaScript loaded for any purpose, including JavaScript
            that is not part of any of the Widgets on the Web Page.
          </t>
          <t>
            Backplane Clients trust the Bus owner and the authenticity
            of Backplane Messages received through a Bus, i.e all
            Backplane Clients that were granted permission to post on
            the Bus by its owner.
          </t>
        </list>
      </t>
    </section>

    <section anchor="access.levels" title="Access Levels">

      <t>
        Considering the significantly different security enforcement
        capabilities of applications running in a web browser versus the
        ones running on a web server, two access levels are defined for
        Backplane Clients: Regular and Privileged.
      </t>

      <t>
        Each access level is exercised for retrieving messages from the
        <xref target="server.api.messages.get">Get Messages</xref> endpoint
        by presenting either a regular or a privileged access token
        obtained from the
        <xref target="server.api.token.post">token</xref> endpoint.
        The access token MUST be presented as described
        in <xref target="OAuth2.token.bearer">section 2.1</xref>.
      </t>

      <t>
        Backplane Servers MUST validate the access token presented
        with all requests received at the
        <xref target="server.api.messages.get">Get Messages</xref>
        endpoint and determine the access level associated with it.
      </t>

      <section anchor="access.level.regular" title="Regular Access">
        <t>
          Regular access level is given to Backplane Clients running in
          the web browser (Widgets and the Backplane JavaScript Library)
          and are obtained through anonymous calls to the
          <xref target="server.api.token.post">token</xref> endpoint.
        </t>
        <t>
          Bus owners and Backplane Servers acting on their behalf MUST
          NOT give authorization credentials for Privileged access level
          to Backplane Clients running in the web browser.
        </t>
        <t>
          Backplane Servers MUST only make Backplane Message Headers
          (not full Backplane Messages) available to Clients having
          Regular access level.
        </t>
      </section>

      <section anchor="access.level.privileged" title="Privileged Access">
        <t>
          Privileged access level is given to Backplane Clients that
          are not running in a web browser (typically the Widgets'
          server-side components) and are obtained through authenticated
          calls to the
          <xref target="server.api.token.post">token</xref> endpoint.
        </t>
        <t>
          Backplane Clients having Privileged access level can perform
          the following operations on a Bus for which they have obtained
          <xref target="authorization">authorization</xref> credentials
          from the Bus owner:
          <list style="symbols">
            <t>
              retrieve all Backplane Messages sent to the Bus [[[  xref ]]]
            </t>
            <t>
              post Backplane Messages to a Channel [[[ xref ]]]
            </t>
          </list>
        </t>
        <section anchor="auth.privileged.authorization" title="Authorization">
          <t>
            <xref target="client.registration">Registered</xref>
            Backplane Clients must be authorized with Privilged Access
            Level. This can be done in one of the following ways:
            <list style="symbols">
              <t>
                By Backplane Server administrators. It is outside of
                the scope of this specification how the administrators
                learn from their customers, the Bus Owners, the Buses
                and Backplane Clients to be authorized with Privileged
                Access.
              </t>
              <t>
                By Bus Owners, through an administrative interface
                provided by the Backplane Server. The interactions
                between a Backplane Server and its Bus Owner customers
                (e.g. registration, authentication, Bus allocation)
                remain outside of the scope of this specification.
              </t>
            </list>
          </t>

        </section>
      </section>
    </section>
    <section anchor="discovery.registration.authorization" title="Discovery, Registration and Authorization">

      <t>
        For a functional setup, the Bus Owners, Backplane Servers and
        Backplane Clients needing Privileged Access have to perform
        the following preliminary interactions:
        <list style="symbols">
          <t>
            Bakplane Clients must
            <xref target="server.discovery">discover</xref> Backplane
            Servers' endpoints for registration, authorization, token,
            message.
          </t>
          <t>
            Backplane Clients must
            <xref target="client.registration">register</xref> with
            Backplane Servers.
          </t>
          <t>
            Bus Owners must
            <xref target="authorization">authorize</xref> Backplane 
            Clients with Privileged Access.
          </t>
        </list>
      </t>

      <section anchor="server.discovery" title="Backplane Server Discovery">
        <section anchor="server.discovery.dynamic" title="Dynamic Discovery">
          <t>
            It is RECOMMENDED that Backplane Servers support dynamic
            discovery, as described in
            <xref target="OAuth.Dynamic.Client.Registration"/> section
            5.  Discovery of Server's Client Registration Endpoint.
            [[[ doesn't cover authorization/token endpoints, it probably should ]]]
          </t>
        </section>
        <section anchor="server.discovery.static" title="Static Discovery">
          <t>
            When dynamic discovery is not available, Backplane Clients
            must independently acquire and keep configuration entries
            for the registration, authorization, token and message
            endpoints of the Backplane Servers they wish to interact
            with.
          </t>
        </section>
      </section>

      <section anchor="client.registration" title="Backplane Client Registration">

        <t>
          Backplane Clients need to be registered with the Backplane
          Server in order to be authorized with
          <xref target="access.level.privileged">Privileged Access</xref>.
        </t>
        
        <t>
          As part of the registration process Backplane Servers MUST
          associate with each client a message source URL that will be 
          used as the <spanx style="emph">source</spanx> field value for
          the messages posted by that client. 
        </t>

        <t>
          Backplane Servers SHOULD provide one of the following
          registation methods, listed in decreasing order of preference.
        </t>

        <section anchor="client.registration.dynamic" title="Dynamic Client Registration">
          <t>
            It is RECOMMENDED that Backplane Servers and Backplane
            Clients employ
            <xref target="OAuth.Dynamic.Client.Registration"/> as
            described in sections "6. Client Registration with Pushed
            Metadata" and "7. Client Registration with Pushed URL and
            Pulled Metadata".
          </t>
        </section>

        <section anchor="client.registration.static" title="Static Client Registration">
          <t>
            Backplane Servers MAY provide an administrative interface
            through which Bus Owners can register Backplane Clients.
            The interactions between a Backplane Server and its
            Bus Owner customers (e.g. registration, authentication, Bus
            allocation) remain outside of the scope of this
            specification.
          </t>
          <t>
            For the purpose of Privileged Access Level authorization a
            server-side Backplane Client needs to be identified by a URL
            that corresponds to the Redirection URI defined in
            <xref target="OAuth2">section 2.1.1</xref> and used
            in the authorization step in
            <xref target="OAuth2">section 4</xref>.
            The redirection URI MUST be obtained and approved by the Bus
            Owner administrator. Backplane Servers may assist Bus Owner
            administrators by providing the redirection URIs of well known
            Backplane Clients (such as popular Widget providers) in their
            administration user interface.
          </t>
          <t>
            When completing a
            <xref target="authorization.server.initiated">Backplane Server Initiated Authorization</xref>
            if the previously unregistered Backplane Client opted to
            also send client credentials, the Backplane Server MAY
            <xref target="client.registration.static">register</xref>
            the Backplane Client. The Backplane Server MUST verify all
            of the following:
            <list style="symbols">
              <t>
                The grant_type is "code".
              </t>
              <t>
                The code is present and the value is recognized as a
                previously issued, one-time use, valid code.
              </t>
              <t>
                The redirect_uri is present and matches the
                redirect_uri for which the supplied code was
                issued.
              </t>
              <t>
                The client_id is present and is different than
                "anonymous" or any other already registered client_id.
              </t>
            </list>
          </t>
          <t>
            Backplane Servers MAY register the redirect_uri as the
            message source URL associated with the client.
          </t>
          <t>
            After a successful registration the Backplane Server
            MUST continue processing the
            <xref target="server.api.token.authenticated">Authenticated Access Token Request</xref>
          </t>

        </section>

        <section anchor="client.registration.manual" title="Manual Client Registration">
          <t>
            As a last resort, Backplane Server administrators MAY
            manually register Backplane Clients and make them available
            to Bus Owners for Privileged Access authorization.
          </t>
        </section>

      </section>

      <section anchor="authorization" title="Authorization">

        <section anchor="authorization.client.initiated" title="Backplane Client Initiated Authorization">
          <t>
            A Bus Owner MAY initiate standard OAuth 2.0 authorization
            code flow from the Backplane Client as described in
            <xref target="OAuth2">section 4.1 Authorization Code</xref>,
            if supported by the Backplane Client. Backplane Servers
            SHOULD support the standard OAuth Authorization Code flow.
          </t>


        </section>

        <section anchor="authorization.server.initiated" title="Backplane Server Initiated Authorization">
          <t>
            Backplane Servers MAY provide an administrative interface
            through which Bus Owners can initiate the authorization of
            <xref target="client.registration">registered</xref>
            Backplane Clients using a slightly modified OAuth
            Authorization Code flow described in this section.
          </t>
          <t>
            Once the Backplane Client has been identified and the Bus
            Owner has selected the Buses for authorization, the
            Backplane Server persists the authorization grant,
            generates an OAuth code for it and sends it with an
            unsolicited OAuth Authorization Response to the Backplane
            Client's redirection URI. The successful authorization
            response SHOULD contain a space sperated list with the
            authorized Bus names in the
            <spanx style="emph">scope</spanx> field.
          </t>
          <t>
            Since an unsolicited OAuth Authorization Response is issued,
            the Backplane Server's
            <xref target="server.api.token.post">token</xref> endpoint
            MUST be identified in the Redirection URI using a query
            parameter named
            <spanx style="emph">bp_token_endpoint</spanx>.
          </t>
          <t>
            The Backplane Client continues by following the OAuth
            Authorization Code flow from this point, and exchanges the
            authorization code for an access token at the Backplane
            Server's token endpoint, as described in
            <xref target="OAuth2">sections 4.1.3 and 4.1.4</xref> and
            <xref target="server.api.token.post">Access Token Request</xref>.
          </t>
        </section>

      </section>

    </section>

    <section anchor="padded.response" title="Padded Responses">
      <t>
        For API requests made by the Javascript Library, the response
        is formatted specially.
      </t>
      <t>
        The response body begins with the value of
        the <spanx style="emph">callback</spanx> parameter from the
        request.  That value is followed by a &quot;(&quot; (opening
        parenthesis), then the JSON-encoded result value, then a
        &quot;)&quot; (closing parenthesis).
      </t>
    </section>

    <section anchor="buses" title="Buses">
      <t>
        A Bus is a logical grouping of Backplane Clients that need to
        interact with each other, typically belonging to one
        organization. Buses allow a Backplane Server to service
        multiple customers. Bus names are short strings
        referencing the Bus owner's name (e.g. "customer.com",
        "organization.org").
        Backplane Clients must know the identifiers for the Buses through
        which they wish to exchange Backplane Messages.
      </t>
      <t>
        It is assumed that a relationship of trust exists between all
        clients granted permission to post messages to a specific
        Bus (see <xref target="trust">Trust</xref>).
      </t>
    </section>

    <section anchor="channels" title="Channels">
      <t>
        A Channel is a subset of Backplane Messages that belong to a Bus
        and are addressed to the Backplane Clients interacting with the
        end user through a single session and Web Page. A Channel is
        similar to a session identifier for the user but is shared by
        multiple Backplane Clients.
      </t>

      <t>Channels are:
        <list style="symbols">
          <t>allocated within Buses</t>
          <t>referenced by unique, unguessable identifiers</t>
          <t>created implicitly once a Backplane Message gets
            posted to a channel that doesn't yet exist</t>
          <t>non-persistent and expire after being inactive (no
            messages posted) for specific amount of time (e.g. 30
            minutes)</t>
          <t>sensitive; see <xref target="channel.sensitivity">Channel Name Sensitivity</xref>.</t>
        </list>
      </t>

      <t>
        Channel identifiers are used by Backplane Clients for message
        retrieval. All Backplane Clients that know a given Channel identifier
        can receive Backplane Messages posted to that Channel.
      </t>

      <t>
        Channel identifiers MUST only contain characters from the
        <xref target="RFC4648.section5">base64url</xref> character set
        and be at least 32 characters long. New channels are generated
        only on
        <xref target="server.api.token.anonymous">anonymous access token requests</xref>.
      </t>
      <t>
        The channel name MUST NOT be guessable given knowledge of the
        algorithms in use or any details of the request being made
        (<xref target="RFC4086">RFC 4086</xref> discusses the
        requirements and pitfalls of generating unguessable values
        in great detail).
      </t>
      <t>
        There can be at most one channel active on a Web Page at a
        given time.
      </t>
    </section>

    <section anchor="backplane.messages" title="Backplane Messages">
      <t>A Backplane message is a JSON object with the following fields:
        <list style="hanging">
          <t hangText="messageURL (string)">
            a URL that a client can use to retrieve the message
          </t>
          <t hangText="source (string)">
            an URL identifying the client which posted the message,
            associated with the client during
            <xref target="client.registration">registration</xref>
          </t>
          <t hangText="type (string)">
            opaque to the core Backplane specification; value, semantic
            and associated payload format is defined in application
            scenario specifications
          </t>
          <t hangText="bus (string)">
            the name of the Bus the message was posted to
          </t>
          <t hangText="channel (string)">
            the identifier of Channel the message was posted to
          </t>
          <t hangText="sticky (boolean)">
            sticky flag. See
            <xref target="server.retention.sticky">Sticky Messages</xref>
          </t>
          <t hangText="payload (object)">
            arbitrary data specific to the particular message type
          </t>
        </list>
      </t>

      <t>
        The presence of certain fields in a Backplane message depends on the
        context it appears in.
      </t>

      <t>
        A downstream (server-to-client) Backplane message delivered to
        a client with
        <xref target="access.level.privileged">privileged access</xref>
        MUST contain all the fields listed above; downstream messages
        delivered to
        <xref target="access.level.regular">regular access</xref>
        clients MUST contain all except the "payload" field from the
        fields listed above.
      </t>

      <t>
        An upstream (client-to-server) Backplane message MUST contain
        the fields "bus", "channel", "payload", "type", it MAY contain
        the "sticky" field and MUST NOT contain any other fields. If the
        "sticky" field is omitted the Backplane Server MUST consider the
        posted message non-sticky.
      </t>

      <figure>
        <preamble>
          Example downstream Backplane Message:
        </preamble>
        <artwork type="code">
{
        "bus": "customer.com",
        "channel": "67dc880cc265b0dbc755ea959b257118",
        "messageURL": "https://bp.example.com/v2/message/097a5cc401001f95b45d37aca32a3bd2",
        "source": "http://aboutecho.com",
        "payload": {
                "role": "administrator"
        },
        "type": "identity/ack",
        "sticky": false
}
        </artwork>
      </figure>

    </section>

    <section anchor="server.retention" title="Message Retention">

      <t>
        Backplane Servers MUST maintain a buffer of messages received
        from all their clients until messages become older than a
        certain threshold. Such threshold MUST be no less than 1 minute.
        It is RECOMMENDED that Backplane Servers set the threshold to at
        least 5 minutes. A message is considered obsolete once its age
        reaches the threshold.
      </t>

      <t>
        It is RECOMMENDED that Backplane Servers make messages available
        for retrieval as soon as possible after they are posted.
      </t>

      <t>
        Backplane Clients that require reliable message delivery
        MUST poll their Backplane Servers with an interval of 30
        seconds or less in order to avoid omissions.
      </t>

      <section anchor="server.retention.sticky" title="Sticky Messages">
        <t>
          Some Backplane application scenarios may require longer
          lived Backplane Messages, such as for keeping a shared state
          about a end user's logged-in identity or profile data.
        </t>

        <t>
          Support for such scenarios is accomplished by flagging
          messages as "sticky" when they are posted (see
          <xref target="server.api.messages.post">Post Messages To A Channel</xref>).
          Backplane Servers MUST retain sticky messages for at least X
          minutes. It is RECOMMENDED that Backplane Servers retain
          sticky messages for Y minutes.
        </t>

        <t>
          Backplane Clients can request retrieval of Backplane Frames
          that only encapsulate sticky messages by using the "sticky"
          <xref target="token.scopes">Access Scope</xref> filter. 
          See also
          <xref target="message.sequence.retrieval">Message Retrieval Conventions</xref>
          below.
        </t>

        <t>
          Application scenario protocols MUST specify the criteria for
          posting sticky messages, if any, such as defining certain
          message types or operations as sticky.
        </t>

        <t>
          Application scenario protocols SHOULD define sticky messages
          in such a way as to minimize the number of sticky messages
          that may be retained by the Backplane Server at any one time
          for a channel, in order to reduce complexity of retrieval and
          processing by the Backplane Clients that rely on them.
        </t>
      </section>

    </section>

    <section anchor="message.sequence.retrieval" title="Message Sequences and Retrieval">
      <t>
        Backplane Clients may wish to retrieve a subset of all the
        messages they have access to, such as belonging to certain Buses
        or Channels, having a certain type, source, or other attributes
        such as sticky.
      </t>
      <t>
        A Message Sequence is the subset of the entire stream of
        Backplane Messages that match a filter criteria, in the same
        order as they have been received by a Backplane server.
      </t>
      <t>
        The <xref target="server.api.token.post">token</xref> endpoint
        is used to obtain an access token tailored to the filter
        criteria desired by the client. The access token is used
        at the
        <xref target="server.api.messages.get">Get Messages</xref>
        endpoint to retrieve the messages in the current buffer that
        belong to the associated Message Sequence.
      </t>
      <t>
        The Message Identifier of the last Backplane Message in a
        retrieved batch of messages is returned as the value of the
        "since" query parameter of the nextURL response field, such that
        the nextURL value will point to the messages that will
        immediately follow in the buffer and will not retrieve any of
        the messages that were already retrieved.
      </t>
      <t>
        If a Message Identifier points to a message that is no longer
        in the buffer, the associated filter criteria is evaluated
        against the entire current buffer.
      </t>

      <section anchor="token.scopes" title="Access Scopes">
        <t>
          The filter criteria for defining a Message Sequence are passed
          to the token endpoint when
          <xref target="server.api.token.post">requesting access tokens</xref>
          as a space-delimited list of access scopes in the following
          format:
          <list style="hanging">
            <t hangText="Access Scope Format:">
              &lt;<spanx style="emph">message_field_name</spanx>&gt;:&lt;<spanx style="emph">message_field_value</spanx>&gt;
            </t>
          </list>
          where <spanx style="emph">message_field_name</spanx> is any
          of the
          <xref target="backplane.messages">defined message field names</xref>,
          and <spanx style="emph">message_field_value</spanx> is the
          expected field's value.
        </t>
        <t>
          An access scope is evaluated by performing a case-sensitive
          string comparison between the expected field's value in the
          access scope, and the field value from the Backplane Message.
        </t>
        <t>
          A list of access scopes is evaluated as follows:
          <list style="symbols">
            <t>
              a logical OR operation is performed for all access scopes having the same field name
            </t>
            <t>
              a logical AND operation is performed among all access scopes having different field names
            </t>
          </list>
        </t>
        <t>
        <figure>
          <preamble>
            Example access scopes: all sticky messages of type
            "identity/ack" posted by "http://aboutecho.com" to any
            channel belonging to the "customer.com" bus.
          </preamble>
          <artwork type="code">
bus:customer.com source:http://aboutecho.com type:identity/ack sticky:true
          </artwork>
        </figure>
        </t>

        <t>
        <figure>
          <preamble>
            Example access scopes: all messages (belonging to bus A OR bus B) AND (having type C OR type D) 
          </preamble>
          <artwork type="code">
bus:A bus:B type:C type:D
          </artwork>
        </figure>
        </t>

        <t>
          When issuing or verifying the scope of an access token,
          Backplane Servers MUST enforce that the requester is
          authorized with
          <xref target="access.level.privileged">Privileged Access</xref>
          for all "<spanx style="emph">bus:</spanx>" access scopes.
        </t>
        <t>
          Application scenario protocol extensions MAY define
          additional authorization requirements against other scope
          type and Backplane Message fields.
        </t>

      </section>

    </section>

    <section anchor="server.api" title="Backplane Server API">

      <section anchor="server.api.token.post" title="Access Token Request">
        <t>
          The OAuth "Token Endpoint" as defined in 
          <xref target="OAuth2">section 2.2</xref> is used to obtain an
          access token to be used for retrieving messages from the
          <xref target="server.api.messages.get">Get Messages</xref>
          endpoint.
        </t>
        <t>
          <list style="hanging">
            <t hangText="Endpoint">/v2/token</t>
            <t hangText="HTTP mehod">POST</t>
            <t hangText="Security">HTTPS</t>
            <t hangText="Parameters">
              The parameters constitute an access token request as
              defined in either
              <xref target="OAuth2">section 4.1.3</xref>
              ( "code" grant type) or
              <xref target="OAuth2">section 4.4.2 </xref>
              ("client credentials" grant type).
              The parameters MUST be passed in the request body using 
              the "application/x-www-form-urlencoded" format:
              <list style="symbols">
                <t>client_id (string, REQUIRED)</t>
                <t>client_secret (string, OPTIONAL)</t>
                <t>grant_type:
                  MUST be "client_credentials" or "code"
                </t>
                <t>code (string):
                  REQUIRED if and only if grant_type is "code"
                </t>
                <t>redirect_uri (string):
                  REQUIRED if and only if grant_type is "code"
                </t>
                <t>scope (string, OPTIONAL):
                  a list of space-delimited
                  <xref target="token.scopes">filter criteria</xref>
                  for the messages the client is interested in.
                </t>
              </list>
            </t>
            <t hangText="Returns">
              On success, a JSON object is returned per
              <xref target="OAuth2">section 5.1</xref>
              with the following fields:
              <list style="symbols">
                <t>token_type: MUST be "Bearer"
                  <xref target="OAuth2.token.bearer"/>
                </t>
                <t>access_token: the issued bearer access token
                </t>
                <t>expires_in:
                  the server MUST include the "expires_in" parameter
                  if the issued token is set to expire.
                </t>
                <t>backplane_channel (optional): the Channel name,
                  if one was generated as a result of an anonymous
                  request
                </t>
              </list>
              The server MUST NOT include the "refresh_token" into the response.
            </t>
          </list>
          <figure>
            <preamble>
              Response example
            </preamble>
            <artwork type="code">
{
  "access_token": "465203f03680f59b7ddd5e1e5d851461",
  "token_type": "Bearer",
  "backplane_channel": "0a92d76f54f7877a68abe19c5b3ffcf8"
}
            </artwork>
          </figure>
        </t>

        <section anchor="server.api.token.anonymous" title="Anonymous Access Token Request">
          <t>
            If the "grant_type" parameter is "client_credentials" and
            the "client_id" parameter is set to "anonymous", the
            request is an anonymous access token request. The client
            MUST omit the "client_secret" parameter in this case. The
            server MUST ignore the value of the "scope" parameter.
          </t>
          <t>
            In response to a anonymous access token request the
            Backplane Server allocates a
            <xref target="channels">new channel</xref> and issues a
            <xref target="access.level.regular">regular access token</xref>
            to the client (no message payloads) for the channel. New
            channels are generated only anonymous access token requests.
            The channel is not bound to a bus until the first message is
            posted to the channel (see
            <xref target="server.api.messages.post">Post Messages</xref>).
          </t>
          <t>
            Regular access tokens issued in response to anonymous access
            token requests MUST expire. It is RECOMMENDED that such
            tokens expire within 1 hour after having been issued.
          </t>
          <t>As an operational note, this API call SHOULD NOT be
            implemented in a way that makes it capable of blocking and
            use of one of the mechanisms in section 7 of
            <xref target="RFC4086">RFC 4086</xref> is RECOMMENDED.
          </t>
        </section>

        <section anchor="server.api.token.authenticated" title="Authenticated Access Token Request">
          <t>
            If the "grant_type" parameter is "code" and both "client_id"
            and "client_secret" are present, the server MAY attempt
            <xref target="client.registration.static">Static Client Registration</xref>.
          </t>
          <t>
            The server MUST check the credentials of the client. If the
            credentials are valid, the request is a authenticated access
            token request; otherwise the server MUST return error per
            <xref target="OAuth2">section 5.2</xref> (error
            "unautorized_client").
          </t>
          <t>
            The server MUST check that the client making the request is
            authorized for the requested scopes. If the client is not
            authorized for any of the requested scopes the server MUST
            return error per
            <xref target="OAuth2">section 5.2</xref> (error
            "invalid_scope").
          </t>
          <t>
            In response to a authenticated access token request the
            Backplane Server issues an
            <xref target="access.level.privileged">privileged access token</xref>
            to the client for the requested scope. If no "scope"
            parameter was specified in the request, the client is
            granted access to all buses it is authorized to per the
            server configuration.
          </t>
        </section>

      </section>

      <section anchor="server.api.messages.get" title="Get Messages">
        <t>
          Retrieve messages from the server.
        </t>
        <t>
          <list style="hanging">
            <t hangText="Endpoint">/v2/messages</t>
            <t hangText="HTTP mehod">GET</t>
            <t hangText="Security">HTTPS</t>
            <t hangText="Authorization">
              The client MUST present the access token obtained from a
              <xref target="server.api.token.post">Access Token Request</xref>
              as described in
              <xref target="OAuth2.token.bearer">section 2.1</xref>.
              The server MUST retrieve the 
              <xref target="token.scopes">Access Scopes</xref>
              associated with the presented access token, determine the
              <xref target="message.sequence.retrieval">Message Sequence</xref>
              filter and <xref target="access.levels">access level</xref>,
              and respond accordingly.
            </t>
            <t hangText="Parameters">
              <list style="symbols">
                <t>block (integer, default 0):
                  if no messages are available for immediate retrieval,
                  this parameter communicates how long (in seconds) the
                  server should wait before returning an empty response
                </t>
                <t>callback (string, optional):
                  callback function to pad the response with (see
                  <xref target="padded.response">Padded Responses</xref>);
                  MUST only contain alphanumeric characters (a-zA-Z0-9)
                </t>
                <t>since (optional, string): the Message Identifier
                  representing the starting point of the requested
                  Message Sequence. See
                  <xref target="message.sequence.retrieval">Message Sequences and Retrieval</xref>.
                </t>
              </list>
            </t>
            <t hangText="Returns">
              On success, a JSON object is returned
              with the following fields:
              <list style="symbols">
                <t>nextURL (string):
                  a complete URL pointing to the Get Messages endpoint
                  that the client can invoke to retrieve subsequent
                  messages from the server. The URL MUST contain a
                  Message Identifier in the
                  <spanx style="emph">since</spanx> query parameter.
                </t>
                <t>messages[]:
                  an array of messages in the order they were originally
                  received by the server. Each message within the array
                  is represented as a JSON object of the same structure
                  as returned by the
                  <xref target="server.api.message.get">Get Single Message</xref>
                  API method.
                </t>
              </list>
              <figure>
                <preamble>
                  Response example
                </preamble>
                <artwork type="code">
{
  "nextURL": "https://bp.example.com/v2/messages?since=958bfa2dd8aed82c86afbd54b4a314a5",
  "messages": [
    {
      "bus": "customer.com",
      "channel": "67dc880cc265b0dbc755ea959b257118",
      "messageURL": "https://bp.example.com/v2/message/097a5cc401001f95b45d37aca32a3bd2",
      "payload": {
        "role": "administrator"
      },
      "source": "http://aboutecho.com",
      "type": "identity/ack"
    }
  ]
}
                </artwork>
              </figure>
            </t>
          </list>
        </t>

      </section>

      <section anchor="server.api.message.get" title="Get Single Message">
        <t>
          Retrieve a single message from the server.
        </t>
        <t>
          <list style="hanging">
            <t hangText="Endpoint">/v2/message/&lt;msg_id&gt;:
              The full endpoint URL constitutes the
              <spanx style="emph">messageURL</spanx> obtained from a
              <xref target="server.api.messages.get">Get Messages</xref> 
              response.
            </t>
            <t hangText="HTTP mehod">GET</t>
            <t hangText="Security">HTTPS</t>
            <t hangText="Authorization">
              The client MUST present the access token obtained from a
              <xref target="server.api.token.post">Access Token Request</xref>
              as described in
              <xref target="OAuth2.token.bearer">section 2.1</xref>,
              to prove that it has access to the message.
              The server MUST retrieve the
              <xref target="token.scopes">Access Scopes</xref>
              associated with the presented access token, determine its
              <xref target="access.levels">access level</xref> and respond
              accordingly with either a Backplane Header, a Backplane
              Message (including payload), or error.
            </t>
            <t hangText="Query parameter">
              <list style="symbols" >
                <t>callback (string, optional):
                  callback function to pad the response with (see
                  <xref target="padded.response">Padded Responses</xref>);
                  MUST only contain alphanumeric characters (a-zA-Z0-9)
                </t>
              </list>
            </t>
            <t hangText="Returns">
              <list style="symbols">
                <t>
                  HTTP status code 404 ("Not Found") if the message is
                  no longer available.
                </t>
                <t>
                  HTTP status code 403 ("Forbidden") if the client
                  is not authorized to retrieve messages from the Bus
                  the message belongs to.
                </t>
                <t>
                  On success, a HTTP status code 200 ("OK") is returned,
                  with the response body containing a Backplane Message
                  JSON object, with the following fields:
                  <list style="symbols">
                    <t>messageURL (string):
                      the URL of the message, see
                      <xref target="server.api.message.get">Get Single Message</xref>
                    </t>
                    <t>source (string):
                      an arbitrary URL identifying the client which has posted the message.
                    </t>
                    <t>type (string):
                      message type (arbitrary string).
                    </t>
                    <t>bus (string):
                      the bus name the message was posted to
                    </t>
                    <t>channel (string):
                      the channel name the message was posted do.
                    </t>
                    <t>payload (object, optional):
                      message payload. Only available to privileged access clients.
                    </t>
                  </list>
                </t>
              </list>
            </t>
          </list>
          <figure>
            <preamble>
              Response example:
            </preamble>
            <artwork type="code">
{
  "messageURL": "https://bp.example.com/v2/message/097a5cc401001f95b45d37aca32a3bd2",
  "source": "http://aboutecho.com",
  "type": "identity/ack"
  "bus": "customer.com",
  "channel": "67dc880cc265b0dbc755ea959b257118",
  "payload": {
    "role": "administrator"
  },
}
            </artwork>
          </figure>
        </t>
      </section>

      <section anchor="server.api.messages.post" title="Post Messages">
        <t>
          Publish messages to the Backplane.
        </t>
        <t>
          <list style="hanging">
            <t hangText="Endpoint">/v2/messages</t>
            <t hangText="HTTP mehod">POST</t>
            <t hangText="Security">HTTPS</t>
            <t hangText="Authorization">
              The client MUST present the access token obtained from a
              <xref target="server.api.token.post">Access Token Request</xref>
              as described in
              <xref target="OAuth2.token.bearer">section 2.1</xref>.
              The server MUST retrieve the
              <xref target="token.scopes">Access Scopes</xref>
              associated with the presented access token and determine
              that it has
              <xref target="access.level.privileged">Privileged Access Level</xref>
              for each of the Buses referenced in the request body.
            </t>
            <t hangText="Request body">
              The body of the request is a JSON object of the following
              structure:
              <list style="symbols">
                <t>messages[]:
                  an array of messages to be posted, represented as JSON
                  objects of the following structure:
                  <list style="symbols">
                    <t>
                      source (string):
                      an arbitrary URL identifying the client which has
                      posted the message
                    </t>
                    <t>
                      type (string):
                      message type (arbitrary string)
                    </t>
                    <t>
                      bus (string):
                      the name of the bus to post the message to
                    </t>
                    <t>
                      sticky (boolean, optional):
                      the <xref target="server.retention.sticky">sticky</xref>
                      flag; if omitted the Backplane Server MUST consider the
                      posted message non-sticky
                    </t>
                    <t>
                      channel (string):
                      the name of the channel to post the message to
                    </t>

                    <t>payload (object):
                      the message payload
                    </t>
                  </list>
                </t>
              </list>
            </t>
            <t hangText="Returns">
              <list style="symbols">
                <t>
                  HTTP status code 201 ("Created") upon success.
                </t>
                <t>
                  HTTP status code 403 ("Forbidden") if the client is
                  not authorized to post messages to any of the
                  referenced Buses. The server processes the messages
                  in the request one by one; if a message can't be
                  posted for any reason, the whole request fails and
                  none of the messages get posted.
                </t>
              </list>
            </t>
          </list>


          The server MUST check that the channel in a message was
          previously allocated as a result of a
          <xref target="server.api.token.post">Access Token Request</xref>.
          If the channel is not yet bound to a bus, the server MUST bind
          it to the bus specified in the same message object from the
          request.
          If the channel is already bound to a different bus than the
          one specified in the same message object in the request, the
          entire request is considered invalid and is aborted.
          <figure>
            <preamble>
              Request example:
            </preamble>
            <artwork type="code">
{
  "messages": [
    {
      "source": "http://aboutecho.com",
      "type": "identity/ack"
      "bus": "customer.com",
      "channel": "67dc880cc265b0dbc755ea959b257118",
      "payload": {
        "role": "administrator"
      },
    },
    {
      "source": "http://aboutecho.com",
      "type": "identity/ack"
      "bus": "organization.org",
      "channel": "d7a592b31fbbc2baf5f9476884b9acd5",
      "payload": {
        "role": "moderator"
      },
    }
  ]
}
            </artwork>
          </figure>
        </t>

      </section>

    </section>

    <section anchor="javascript.api" title="Backplane JavaScript API">

      <t>A Backplane JavaScript Library runs in an end user's browser
        and mediates communication between Backplane-enabled Widgets on
        the page and the Backplane Server.</t>

      <t>Only one instance of the Backplane JavaScript Library on a
        given page is possible. The library has to be the first to load
        on the page to make it possible for other scripts to use its
        subscription functionality.</t>

      <figure>
        <preamble>The Backplane JavaScript Library provides the following
          API (all methods are static): </preamble>
        <artwork type="code">
/**
 * Initializes the backplane library
 *
 * @param {Object} Params - hash with configuration parameters.
 *   Possible hash keys:
 *     serverBaseURL (required) - Base URL of Backplane Server
 *     busName (required) - Customer's backplane bus name
 */
Backplane.init(Params);

/**
 * Subscribes to messages from Backplane server
 *
 * @param {Function} Callback - Callback function which accepts backplane messages.
 * @returns Subscription ID which can be used later for unsubscribing.
 */
Backplane.subscribe(Callback);

/**
 * Removes specified subscription
 *
 * @param {Integer} Subscription ID
 */
Backplane.unsubscribe(SubscriptionID);

/**
 * Returns channel ID (like http://backplane.customer.com/v2/bus/customer.com/channel/8ec92f459fa70b0da1a40e8fe70a0bc8)
 *
 * @returns Backplane channel ID
 */
Backplane.getChannelID();

/**
 * Notifies backplane library about the fact that subscribers are going
 * to receive backplane messages within specified time interval.
 *
 * @param {Integer} TimeInterval - Time interval in seconds
 * @param {Array} MessageTypes (optional) - a list of expected message types
 */
Backplane.expectMessagesWithin(TimeInterval, MessageTypes);
        </artwork>
      </figure>

      <section anchor="client.side.library.init"
        title="Initialization">
        <t>Backplane is initialized using the
          <spanx style="verb">Backplane.init</spanx> method.</t>

        <t>During initialization the library generates a random
          Channel Name unless information about one for the specified
          <spanx style="emph">bus name</spanx> already exists in the
          <spanx style="verb">backplane-channel</spanx> cookie. Since
          client-side generation of the channel name is non-secure,
          the library performs a request to obtain a channel name
          from the Backplane Server.</t>

        <t>
          There can be at most one channel active on a Web Page at a
          given time.
        </t>

        <t>After initialization the library stores the current Channel
          Name in the <spanx style="verb">backplane-channel</spanx>
          cookie set against the complete domain name of currently
          opened page. The cookie is set for 5 years in advance and
          keeps information about association of Bus names to Channel
          Names (to support possibility to use the library with several
          different Bus names on the same domain). The information
          about the association is stored in a serialized form.</t>

        <figure>
          <preamble>Here is an example of cookie that stores association
            of Bus names <spanx style="verb">example.com</spanx> and
            <spanx style="verb">example.org</spanx> to the corresponding
            channel names <spanx style="verb">123</spanx> and
            <spanx style="verb">456</spanx>:</preamble>
          <artwork type="example">backplane-channel=example.com:123|example.org:456</artwork>
        </figure>

        <t>After the channel ID has been determined, the library
          performs a first reading of messages from a channel, discards
          all of them (remembering only the identifier of the very
          last one) and starts polling the Backplane Server for new
          messages since the latest Backplane Message. This way the
          library is guaranteed to push to subscribers only those
          Backplane Messages which arrived after the library had been
          fully initialized.</t>

      </section>

      <section anchor="client.side.library.subscription"
          title="Subscription Management">
        <t>The library provides a method for Widgets to set up
          notification callbacks: <spanx style="verb">Backplane.subscribe</spanx>.
          The method returns a subscription id which can be later used
          for unsubscribing using the <spanx style="verb">Backplane.unsubscribe</spanx>
          method.</t>

        <t>After the initialization the library starts polling the
          Backplane Server for new events. All incoming events are
          delivered to the Widgets that have registered callbacks with
          the library. </t>

      </section>
      <section anchor="client.side.library.hints"
          title="Hints">
        <t>For performance reasons the Backplane JavaScript Library
          polls the Backplane Server with a low frequency (e.g once a
          minute). Since Backplane events usually are initiated on the
          client side (e.g. the user clicking a button), Widgets on the
          page are in a position to hint the library that a Backplane
          message may be soon delivered. Upon the receipt of such hint
          (via <spanx style="verb">expectMessagesWithin</spanx> method),
          the library temporarily increases the polling frequency (e.g.
          to once a second) and then gradually decreases it to the
          default low value one.</t>

        <t>The <spanx style="verb">expectMessagesWithin</spanx> method
          can accept an optional list of expected message types.
          <list>
            <t>If the library accepts <spanx style="emph">any</spanx>
              message from the passed message types list, it gradually
              returns to the lower polling frequency mode;</t>
            <t>If messages with only one type are expected, the second
              argument may be specified as a string;</t>
            <t>Each call of the method adds passed message types to the
              list of expected message types. In other words, if
              a user calls the method with a message type "type1" and
              then performs one more call with a message type "type2",
              the library will run in the fast polling mode until it
              received messages of <spanx style="emph">all</spanx>
              the types or until the libray reached the maximum allotted
              waiting time interval.</t>
          </list>
        </t>
      </section>

      <section anchor="client.side.library.example"
          title="Usage Example">
        <figure><artwork type="code">
Backplane.init({
    serverBaseURL: "http://backplane.customer.com/v2",
    busName: "customer.com"
});

var escSubscription = Backplane.subscribe(function(backplaneMessage) {
    alert(backplaneMessage.payload);
});

// We can ask the library to perform more frequent polling
// if a widget, for example, expects a message from Backplane pretty soon
// using the expectMessagesWithin method which accepts
// time interval of possible message arrival in seconds
Backplane.expectMessagesWithin(10);

// The method can accept an option list with expected message types.
// The library stops fast polling when it receives a message of
// either type.
Backplane.expectMessagesWithin(10, ["type1", "type2"]);

// Subsequent calls extend the list of expected message types.
// The library stops fast polling only after it has received
// a message of type1 or type2 AND a message of type3 or type4.
Backplane.expectMessagesWithin(10, ["type3", "type4"]);

Backplane.unsubscribe(escSubscription);

// If a widget needs Backplane channel ID it can get it using the
// getChannelID method
Backplane.getChannelID();
        </artwork></figure>
      </section>
    </section>
    <section title="Security Considerations">
      <t>
        See <xref target="trust">Trust</xref>.
      </t>
      <section anchor="channel.sensitivity" title="Channel Name Sensitivity">
        <t>
          The Channel Name acts as a session identifier shared among a
          group of trusted parties. Knowledge of a Channel Name offers
          Regular Access level to Backplane Server API.
        </t>
        <t>
          It is therefore important that the Channel Name is not
          compromised, by either:
          <list style="symbols">
            <t>
              Trusting any third-party JavaScript source included in the
              Web Page without due verification, or
            </t>
            <t>
              Disclosing Channel Names to untrusted parties.
            </t>
          </list>
        </t>
      </section>
      <section title="Message Payloads">
        <t>
          Message payloads are only sent to Backplane Clients at
          <xref target="access.level.privileged">Privileged Access Level</xref>.
          This is in order to allow sensitive data to be exchanged
          among server-side Backplane Clients, while not allowing it to
          reach the less secure context of web browser.
        </t>
        <t>
          It is therefore important that
          <xref target="access.level.privileged">Privileged Access Level</xref>
          credentials are not provisioned to Backplane Clients that run
          in a web browser.
        </t>
      </section>
    </section>
  </middle>

  <back>
    <references title="Normative References">

      &RFC2616;

      &RFC2617;

      &RFC4627;

      &RFC4086;

      &RFC2119;

      <reference
        anchor="RFC4648.section5"
        target="http://tools.ietf.org/html/rfc4648#section-5">
        <front>
          <title>The Base16, Base32, and Base64 Data Encodings</title>
          <author initials="S." surname="Josefsson"
            fullname="S. Josefsson">
            <organization>SJD</organization>
          </author>
          <date year="2006" month="October" />
        </front>
      </reference>

      <reference
        anchor="OAuth2"
        target="http://tools.ietf.org/html/draft-ietf-oauth-v2">
        <front>
          <title>The OAuth 2.0 Authorization Protocol</title>
          <author initials="E." surname="Habber-Lahav"
            fullname="E. Hammer-Lahav">
            <organization>Yahoo!</organization>
          </author>
          <author initials="D." surname="Recordon"
            fullname="D. Recordon">
            <organization>Facebook</organization>
          </author>
          <author initials="D." surname="Hardt"
            fullname="D. Hardt">
            <organization/>
          </author>
          <date year="2011" month="May" />
        </front>
      </reference>

      <reference
        anchor="OAuth2.token.bearer"
        target="http://tools.ietf.org/html/draft-ietf-oauth-v2-bearer">
        <front>
          <title>The OAuth 2.0 Protocol: Bearer Tokens</title>
          <author initials="M." surname="Jones"
            fullname="M. Jones">
            <organization>Yahoo</organization>
          </author>
          <author initials="D." surname="Hardt"
            fullname="D. Hardt">
            <organization>independent</organization>
          </author>
          <author initials="D." surname="Recordon"
            fullname="D. Recordon">
            <organization>Facebook</organization>
          </author>
          <date year="2011" month="Jun" />
        </front>
      </reference>

      <reference
        anchor="OAuth.Dynamic.Client.Registration"
        target="http://tools.ietf.org/html/draft-hardjono-oauth-dynreg">
        <front>
          <title>OAuth Dynamic Client Registration Protocol</title>
          <author initials="T." surname="Hardjono"
            fullname="T. Hardjono">
            <organization>MIT</organization>
          </author>
          <author initials="M." surname="Machulak"
            fullname="M. Machulak">
            <organization>Newcastle University</organization>
          </author>
          <author initials="E." surname="Maler"
            fullname="E. Maler">
            <organization>XMLgrrl.com</organization>
          </author>
          <author initials="C." surname="Scholz"
            fullname="C. Scholz">
            <organization>COM.lounge GmbH</organization>
          </author>
          <date year="2011" month="Oct" />
        </front>
      </reference>


    </references>
  </back>
</rfc>
<!-- vim: set ts=2 sts=2 sw=2 tw=72 et fdm=marker fmr=[[[,]]]: -->
